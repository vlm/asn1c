
/*** <<< INCLUDES [Int1] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [Int1] >>> ***/

typedef long	 Int1_t;

/*** <<< FUNC-DECLS [Int1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int1;
asn_struct_free_f Int1_free;
asn_struct_print_f Int1_print;
asn_constr_check_f Int1_constraint;
ber_type_decoder_f Int1_decode_ber;
der_type_encoder_f Int1_encode_der;
xer_type_decoder_f Int1_decode_xer;
xer_type_encoder_f Int1_encode_xer;
per_type_decoder_f Int1_decode_uper;
per_type_encoder_f Int1_encode_uper;

/*** <<< CODE [Int1] >>> ***/

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Int1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int1 = {
	"Int1",
	"Int1",
	&asn_OP_NativeInteger,
	NativeInteger_constraint,
	asn_DEF_Int1_tags_1,
	sizeof(asn_DEF_Int1_tags_1)
		/sizeof(asn_DEF_Int1_tags_1[0]), /* 1 */
	asn_DEF_Int1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int1_tags_1)
		/sizeof(asn_DEF_Int1_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int2] >>> ***/

#include "Int1.h"

/*** <<< TYPE-DECLS [Int2] >>> ***/

typedef Int1_t	 Int2_t;

/*** <<< FUNC-DECLS [Int2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int2;
asn_struct_free_f Int2_free;
asn_struct_print_f Int2_print;
asn_constr_check_f Int2_constraint;
ber_type_decoder_f Int2_decode_ber;
der_type_encoder_f Int2_encode_der;
xer_type_decoder_f Int2_decode_xer;
xer_type_encoder_f Int2_encode_xer;
per_type_decoder_f Int2_decode_uper;
per_type_encoder_f Int2_encode_uper;

/*** <<< CODE [Int2] >>> ***/

int
Int2_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int1,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Int2] >>> ***/

static asn_per_constraints_t asn_PER_type_Int2_constr_1 GCC_NOTUSED = {
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (0..MAX) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Int2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int2 = {
	"Int2",
	"Int2",
	&asn_OP_NativeInteger,
	Int2_constraint,
	asn_DEF_Int2_tags_1,
	sizeof(asn_DEF_Int2_tags_1)
		/sizeof(asn_DEF_Int2_tags_1[0]), /* 1 */
	asn_DEF_Int2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int2_tags_1)
		/sizeof(asn_DEF_Int2_tags_1[0]), /* 1 */
	&asn_PER_type_Int2_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int3] >>> ***/

#include "Int2.h"

/*** <<< TYPE-DECLS [Int3] >>> ***/

typedef Int2_t	 Int3_t;

/*** <<< FUNC-DECLS [Int3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int3;
asn_struct_free_f Int3_free;
asn_struct_print_f Int3_print;
asn_constr_check_f Int3_constraint;
ber_type_decoder_f Int3_decode_ber;
der_type_encoder_f Int3_encode_der;
xer_type_decoder_f Int3_decode_xer;
xer_type_encoder_f Int3_encode_xer;
per_type_decoder_f Int3_decode_uper;
per_type_encoder_f Int3_encode_uper;

/*** <<< CODE [Int3] >>> ***/

int
Int3_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int2,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Int3] >>> ***/

static asn_per_constraints_t asn_PER_type_Int3_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 4,  4,  0,  10 }	/* (0..10) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Int3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int3 = {
	"Int3",
	"Int3",
	&asn_OP_NativeInteger,
	Int3_constraint,
	asn_DEF_Int3_tags_1,
	sizeof(asn_DEF_Int3_tags_1)
		/sizeof(asn_DEF_Int3_tags_1[0]), /* 1 */
	asn_DEF_Int3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int3_tags_1)
		/sizeof(asn_DEF_Int3_tags_1[0]), /* 1 */
	&asn_PER_type_Int3_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int4] >>> ***/

#include "Int3.h"

/*** <<< TYPE-DECLS [Int4] >>> ***/

typedef Int3_t	 Int4_t;

/*** <<< FUNC-DECLS [Int4] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int4;
asn_struct_free_f Int4_free;
asn_struct_print_f Int4_print;
asn_constr_check_f Int4_constraint;
ber_type_decoder_f Int4_decode_ber;
der_type_encoder_f Int4_encode_der;
xer_type_decoder_f Int4_decode_xer;
xer_type_encoder_f Int4_encode_xer;
per_type_decoder_f Int4_decode_uper;
per_type_encoder_f Int4_encode_uper;

/*** <<< CODE [Int4] >>> ***/

int
Int4_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int3,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Int4] >>> ***/

static asn_per_constraints_t asn_PER_type_Int4_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED | APC_EXTENSIBLE,  4,  4,  1,  10 }	/* (1..10,...) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Int4] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int4_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int4 = {
	"Int4",
	"Int4",
	&asn_OP_NativeInteger,
	Int4_constraint,
	asn_DEF_Int4_tags_1,
	sizeof(asn_DEF_Int4_tags_1)
		/sizeof(asn_DEF_Int4_tags_1[0]), /* 1 */
	asn_DEF_Int4_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int4_tags_1)
		/sizeof(asn_DEF_Int4_tags_1[0]), /* 1 */
	&asn_PER_type_Int4_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int5] >>> ***/

#include "Int4.h"

/*** <<< TYPE-DECLS [Int5] >>> ***/

typedef Int4_t	 Int5_t;

/*** <<< FUNC-DECLS [Int5] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int5;
asn_struct_free_f Int5_free;
asn_struct_print_f Int5_print;
asn_constr_check_f Int5_constraint;
ber_type_decoder_f Int5_decode_ber;
der_type_encoder_f Int5_encode_der;
xer_type_decoder_f Int5_decode_xer;
xer_type_encoder_f Int5_encode_xer;
per_type_decoder_f Int5_decode_uper;
per_type_encoder_f Int5_encode_uper;

/*** <<< CODE [Int5] >>> ***/

int
Int5_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value == 5)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int4,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Int5] >>> ***/

static asn_per_constraints_t asn_PER_type_Int5_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  5,  5 }	/* (5..5) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Int5] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int5_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int5 = {
	"Int5",
	"Int5",
	&asn_OP_NativeInteger,
	Int5_constraint,
	asn_DEF_Int5_tags_1,
	sizeof(asn_DEF_Int5_tags_1)
		/sizeof(asn_DEF_Int5_tags_1[0]), /* 1 */
	asn_DEF_Int5_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int5_tags_1)
		/sizeof(asn_DEF_Int5_tags_1[0]), /* 1 */
	&asn_PER_type_Int5_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ExtensibleExtensions] >>> ***/

#include <NativeInteger.h>

/*** <<< TYPE-DECLS [ExtensibleExtensions] >>> ***/

typedef long	 ExtensibleExtensions_t;

/*** <<< FUNC-DECLS [ExtensibleExtensions] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ExtensibleExtensions;
asn_struct_free_f ExtensibleExtensions_free;
asn_struct_print_f ExtensibleExtensions_print;
asn_constr_check_f ExtensibleExtensions_constraint;
ber_type_decoder_f ExtensibleExtensions_decode_ber;
der_type_encoder_f ExtensibleExtensions_encode_der;
xer_type_decoder_f ExtensibleExtensions_decode_xer;
xer_type_encoder_f ExtensibleExtensions_encode_xer;
per_type_decoder_f ExtensibleExtensions_decode_uper;
per_type_encoder_f ExtensibleExtensions_encode_uper;

/*** <<< CODE [ExtensibleExtensions] >>> ***/

int
ExtensibleExtensions_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 1 && value <= 256)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeInteger,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [ExtensibleExtensions] >>> ***/

static asn_per_constraints_t asn_PER_type_ExtensibleExtensions_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED | APC_EXTENSIBLE,  8,  8,  1,  256 }	/* (1..256,...) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [ExtensibleExtensions] >>> ***/

static const ber_tlv_tag_t asn_DEF_ExtensibleExtensions_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ExtensibleExtensions = {
	"ExtensibleExtensions",
	"ExtensibleExtensions",
	&asn_OP_NativeInteger,
	ExtensibleExtensions_constraint,
	asn_DEF_ExtensibleExtensions_tags_1,
	sizeof(asn_DEF_ExtensibleExtensions_tags_1)
		/sizeof(asn_DEF_ExtensibleExtensions_tags_1[0]), /* 1 */
	asn_DEF_ExtensibleExtensions_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExtensibleExtensions_tags_1)
		/sizeof(asn_DEF_ExtensibleExtensions_tags_1[0]), /* 1 */
	&asn_PER_type_ExtensibleExtensions_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str1] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [Str1] >>> ***/

typedef IA5String_t	 Str1_t;

/*** <<< FUNC-DECLS [Str1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str1;
asn_struct_free_f Str1_free;
asn_struct_print_f Str1_print;
asn_constr_check_f Str1_constraint;
ber_type_decoder_f Str1_decode_ber;
der_type_encoder_f Str1_encode_der;
xer_type_decoder_f Str1_decode_xer;
xer_type_encoder_f Str1_encode_xer;
per_type_decoder_f Str1_decode_uper;
per_type_encoder_f Str1_encode_uper;

/*** <<< CODE [Str1] >>> ***/

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Str1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str1 = {
	"Str1",
	"Str1",
	&asn_OP_IA5String,
	IA5String_constraint,
	asn_DEF_Str1_tags_1,
	sizeof(asn_DEF_Str1_tags_1)
		/sizeof(asn_DEF_Str1_tags_1[0]), /* 1 */
	asn_DEF_Str1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str1_tags_1)
		/sizeof(asn_DEF_Str1_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str2] >>> ***/

#include "Str1.h"

/*** <<< TYPE-DECLS [Str2] >>> ***/

typedef Str1_t	 Str2_t;

/*** <<< FUNC-DECLS [Str2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str2;
asn_struct_free_f Str2_free;
asn_struct_print_f Str2_print;
asn_constr_check_f Str2_constraint;
ber_type_decoder_f Str2_decode_ber;
der_type_encoder_f Str2_encode_der;
xer_type_decoder_f Str2_decode_xer;
xer_type_encoder_f Str2_encode_xer;
per_type_decoder_f Str2_decode_uper;
per_type_encoder_f Str2_encode_uper;

/*** <<< CTABLES [Str2] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [Str2] >>> ***/

int
Str2_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Str1_t *st = (const Str1_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if(((size <= 20) || (size >= 25 && size <= 30))
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Str1,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Str2] >>> ***/

static asn_per_constraints_t asn_PER_type_Str2_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 7,  7,  0,  127 }	/* (0..127) */,
	{ APC_CONSTRAINED,	 5,  5,  0,  30 }	/* (SIZE(0..30)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [Str2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str2 = {
	"Str2",
	"Str2",
	&asn_OP_IA5String,
	Str2_constraint,
	asn_DEF_Str2_tags_1,
	sizeof(asn_DEF_Str2_tags_1)
		/sizeof(asn_DEF_Str2_tags_1[0]), /* 1 */
	asn_DEF_Str2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str2_tags_1)
		/sizeof(asn_DEF_Str2_tags_1[0]), /* 1 */
	&asn_PER_type_Str2_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str3] >>> ***/

#include "Str2.h"

/*** <<< TYPE-DECLS [Str3] >>> ***/

typedef Str2_t	 Str3_t;

/*** <<< FUNC-DECLS [Str3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str3;
asn_struct_free_f Str3_free;
asn_struct_print_f Str3_print;
asn_constr_check_f Str3_constraint;
ber_type_decoder_f Str3_decode_ber;
der_type_encoder_f Str3_encode_der;
xer_type_decoder_f Str3_decode_xer;
xer_type_encoder_f Str3_encode_xer;
per_type_decoder_f Str3_decode_uper;
per_type_encoder_f Str3_encode_uper;

/*** <<< CTABLES [Str3] >>> ***/

static const int permitted_alphabet_table_1[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  ABC             */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*     def          */
};
static const int permitted_alphabet_code2value_1[6] = {
65,66,67,100,101,102,};


static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [Str3] >>> ***/

int
Str3_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Str2_t *st = (const Str2_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if(((size >= 10 && size <= 20) || (size >= 25 && size <= 27))
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_Str3_1_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_1)/sizeof(permitted_alphabet_table_1[0]))
		return -1;
	return permitted_alphabet_table_1[value] - 1;
}
static int asn_PER_MAP_Str3_1_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_1)/sizeof(permitted_alphabet_code2value_1[0]))
		return -1;
	return permitted_alphabet_code2value_1[code];
}
/*
 * This type is implemented using Str2,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Str3] >>> ***/

static asn_per_constraints_t asn_PER_type_Str3_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  102 }	/* (65..102) */,
	{ APC_CONSTRAINED,	 5,  5,  10,  27 }	/* (SIZE(10..27)) */,
	asn_PER_MAP_Str3_1_v2c,	/* Value to PER code map */
	asn_PER_MAP_Str3_1_c2v	/* PER code to value map */
};

/*** <<< STAT-DEFS [Str3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str3 = {
	"Str3",
	"Str3",
	&asn_OP_IA5String,
	Str3_constraint,
	asn_DEF_Str3_tags_1,
	sizeof(asn_DEF_Str3_tags_1)
		/sizeof(asn_DEF_Str3_tags_1[0]), /* 1 */
	asn_DEF_Str3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str3_tags_1)
		/sizeof(asn_DEF_Str3_tags_1[0]), /* 1 */
	&asn_PER_type_Str3_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str4] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [Str4] >>> ***/

typedef IA5String_t	 Str4_t;

/*** <<< FUNC-DECLS [Str4] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str4;
asn_struct_free_f Str4_free;
asn_struct_print_f Str4_print;
asn_constr_check_f Str4_constraint;
ber_type_decoder_f Str4_decode_ber;
der_type_encoder_f Str4_encode_der;
xer_type_decoder_f Str4_decode_xer;
xer_type_encoder_f Str4_encode_xer;
per_type_decoder_f Str4_decode_uper;
per_type_encoder_f Str4_encode_uper;

/*** <<< CTABLES [Str4] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [Str4] >>> ***/

int
Str4_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Str4] >>> ***/

static asn_per_constraints_t asn_PER_type_Str4_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 7,  7,  0,  127 }	/* (0..127) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [Str4] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str4_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str4 = {
	"Str4",
	"Str4",
	&asn_OP_IA5String,
	Str4_constraint,
	asn_DEF_Str4_tags_1,
	sizeof(asn_DEF_Str4_tags_1)
		/sizeof(asn_DEF_Str4_tags_1[0]), /* 1 */
	asn_DEF_Str4_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str4_tags_1)
		/sizeof(asn_DEF_Str4_tags_1[0]), /* 1 */
	&asn_PER_type_Str4_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PER-Visible] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [PER-Visible] >>> ***/

typedef IA5String_t	 PER_Visible_t;

/*** <<< FUNC-DECLS [PER-Visible] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PER_Visible;
asn_struct_free_f PER_Visible_free;
asn_struct_print_f PER_Visible_print;
asn_constr_check_f PER_Visible_constraint;
ber_type_decoder_f PER_Visible_decode_ber;
der_type_encoder_f PER_Visible_encode_der;
xer_type_decoder_f PER_Visible_decode_xer;
xer_type_encoder_f PER_Visible_encode_xer;
per_type_decoder_f PER_Visible_decode_uper;
per_type_encoder_f PER_Visible_encode_uper;

/*** <<< CTABLES [PER-Visible] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [PER-Visible] >>> ***/

int
PER_Visible_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [PER-Visible] >>> ***/

static asn_per_constraints_t asn_PER_type_PER_Visible_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  70 }	/* (65..70) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [PER-Visible] >>> ***/

static const ber_tlv_tag_t asn_DEF_PER_Visible_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PER_Visible = {
	"PER-Visible",
	"PER-Visible",
	&asn_OP_IA5String,
	PER_Visible_constraint,
	asn_DEF_PER_Visible_tags_1,
	sizeof(asn_DEF_PER_Visible_tags_1)
		/sizeof(asn_DEF_PER_Visible_tags_1[0]), /* 1 */
	asn_DEF_PER_Visible_tags_1,	/* Same as above */
	sizeof(asn_DEF_PER_Visible_tags_1)
		/sizeof(asn_DEF_PER_Visible_tags_1[0]), /* 1 */
	&asn_PER_type_PER_Visible_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PER-Visible-2] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [PER-Visible-2] >>> ***/

typedef PER_Visible_t	 PER_Visible_2_t;

/*** <<< FUNC-DECLS [PER-Visible-2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PER_Visible_2;
asn_struct_free_f PER_Visible_2_free;
asn_struct_print_f PER_Visible_2_print;
asn_constr_check_f PER_Visible_2_constraint;
ber_type_decoder_f PER_Visible_2_decode_ber;
der_type_encoder_f PER_Visible_2_encode_der;
xer_type_decoder_f PER_Visible_2_decode_xer;
xer_type_encoder_f PER_Visible_2_encode_xer;
per_type_decoder_f PER_Visible_2_decode_uper;
per_type_encoder_f PER_Visible_2_encode_uper;

/*** <<< CTABLES [PER-Visible-2] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 69 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [PER-Visible-2] >>> ***/

int
PER_Visible_2_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [PER-Visible-2] >>> ***/

static asn_per_constraints_t asn_PER_type_PER_Visible_2_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  69,  70 }	/* (69..70) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [PER-Visible-2] >>> ***/

static const ber_tlv_tag_t asn_DEF_PER_Visible_2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PER_Visible_2 = {
	"PER-Visible-2",
	"PER-Visible-2",
	&asn_OP_IA5String,
	PER_Visible_2_constraint,
	asn_DEF_PER_Visible_2_tags_1,
	sizeof(asn_DEF_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_PER_Visible_2_tags_1[0]), /* 1 */
	asn_DEF_PER_Visible_2_tags_1,	/* Same as above */
	sizeof(asn_DEF_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_PER_Visible_2_tags_1[0]), /* 1 */
	&asn_PER_type_PER_Visible_2_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Not-PER-Visible-1] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Not-PER-Visible-1] >>> ***/

typedef PER_Visible_t	 Not_PER_Visible_1_t;

/*** <<< FUNC-DECLS [Not-PER-Visible-1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_1;
asn_struct_free_f Not_PER_Visible_1_free;
asn_struct_print_f Not_PER_Visible_1_print;
asn_constr_check_f Not_PER_Visible_1_constraint;
ber_type_decoder_f Not_PER_Visible_1_decode_ber;
der_type_encoder_f Not_PER_Visible_1_encode_der;
xer_type_decoder_f Not_PER_Visible_1_decode_xer;
xer_type_encoder_f Not_PER_Visible_1_encode_xer;
per_type_decoder_f Not_PER_Visible_1_decode_uper;
per_type_encoder_f Not_PER_Visible_1_encode_uper;

/*** <<< CTABLES [Not-PER-Visible-1] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [Not-PER-Visible-1] >>> ***/

int
Not_PER_Visible_1_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Not-PER-Visible-1] >>> ***/

static asn_per_constraints_t asn_PER_type_Not_PER_Visible_1_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  70 }	/* (65..70) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [Not-PER-Visible-1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Not_PER_Visible_1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_1 = {
	"Not-PER-Visible-1",
	"Not-PER-Visible-1",
	&asn_OP_IA5String,
	Not_PER_Visible_1_constraint,
	asn_DEF_Not_PER_Visible_1_tags_1,
	sizeof(asn_DEF_Not_PER_Visible_1_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_1_tags_1[0]), /* 1 */
	asn_DEF_Not_PER_Visible_1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Not_PER_Visible_1_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_1_tags_1[0]), /* 1 */
	&asn_PER_type_Not_PER_Visible_1_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Not-PER-Visible-2] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Not-PER-Visible-2] >>> ***/

typedef PER_Visible_t	 Not_PER_Visible_2_t;

/*** <<< FUNC-DECLS [Not-PER-Visible-2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_2;
asn_struct_free_f Not_PER_Visible_2_free;
asn_struct_print_f Not_PER_Visible_2_print;
asn_constr_check_f Not_PER_Visible_2_constraint;
ber_type_decoder_f Not_PER_Visible_2_decode_ber;
der_type_encoder_f Not_PER_Visible_2_encode_der;
xer_type_decoder_f Not_PER_Visible_2_decode_xer;
xer_type_encoder_f Not_PER_Visible_2_encode_xer;
per_type_decoder_f Not_PER_Visible_2_decode_uper;
per_type_encoder_f Not_PER_Visible_2_encode_uper;

/*** <<< CTABLES [Not-PER-Visible-2] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 66)) return -1;
	}
	return 0;
}


/*** <<< CODE [Not-PER-Visible-2] >>> ***/

int
Not_PER_Visible_2_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Not-PER-Visible-2] >>> ***/

static asn_per_constraints_t asn_PER_type_Not_PER_Visible_2_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [Not-PER-Visible-2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Not_PER_Visible_2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_2 = {
	"Not-PER-Visible-2",
	"Not-PER-Visible-2",
	&asn_OP_IA5String,
	Not_PER_Visible_2_constraint,
	asn_DEF_Not_PER_Visible_2_tags_1,
	sizeof(asn_DEF_Not_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_2_tags_1[0]), /* 1 */
	asn_DEF_Not_PER_Visible_2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Not_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_2_tags_1[0]), /* 1 */
	&asn_PER_type_Not_PER_Visible_2_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Not-PER-Visible-3] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Not-PER-Visible-3] >>> ***/

typedef PER_Visible_t	 Not_PER_Visible_3_t;

/*** <<< FUNC-DECLS [Not-PER-Visible-3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_3;
asn_struct_free_f Not_PER_Visible_3_free;
asn_struct_print_f Not_PER_Visible_3_print;
asn_constr_check_f Not_PER_Visible_3_constraint;
ber_type_decoder_f Not_PER_Visible_3_decode_ber;
der_type_encoder_f Not_PER_Visible_3_encode_der;
xer_type_decoder_f Not_PER_Visible_3_decode_xer;
xer_type_encoder_f Not_PER_Visible_3_encode_xer;
per_type_decoder_f Not_PER_Visible_3_decode_uper;
per_type_encoder_f Not_PER_Visible_3_encode_uper;

/*** <<< CTABLES [Not-PER-Visible-3] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 66)) return -1;
	}
	return 0;
}


/*** <<< CODE [Not-PER-Visible-3] >>> ***/

int
Not_PER_Visible_3_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Not-PER-Visible-3] >>> ***/

static asn_per_constraints_t asn_PER_type_Not_PER_Visible_3_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [Not-PER-Visible-3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Not_PER_Visible_3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_3 = {
	"Not-PER-Visible-3",
	"Not-PER-Visible-3",
	&asn_OP_IA5String,
	Not_PER_Visible_3_constraint,
	asn_DEF_Not_PER_Visible_3_tags_1,
	sizeof(asn_DEF_Not_PER_Visible_3_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_3_tags_1[0]), /* 1 */
	asn_DEF_Not_PER_Visible_3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Not_PER_Visible_3_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_3_tags_1[0]), /* 1 */
	&asn_PER_type_Not_PER_Visible_3_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SIZE-but-not-FROM] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [SIZE-but-not-FROM] >>> ***/

typedef PER_Visible_t	 SIZE_but_not_FROM_t;

/*** <<< FUNC-DECLS [SIZE-but-not-FROM] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SIZE_but_not_FROM;
asn_struct_free_f SIZE_but_not_FROM_free;
asn_struct_print_f SIZE_but_not_FROM_print;
asn_constr_check_f SIZE_but_not_FROM_constraint;
ber_type_decoder_f SIZE_but_not_FROM_decode_ber;
der_type_encoder_f SIZE_but_not_FROM_encode_der;
xer_type_decoder_f SIZE_but_not_FROM_decode_xer;
xer_type_encoder_f SIZE_but_not_FROM_encode_xer;
per_type_decoder_f SIZE_but_not_FROM_decode_uper;
per_type_encoder_f SIZE_but_not_FROM_encode_uper;

/*** <<< CTABLES [SIZE-but-not-FROM] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 68)) return -1;
	}
	return 0;
}


/*** <<< CODE [SIZE-but-not-FROM] >>> ***/

int
SIZE_but_not_FROM_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 4)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [SIZE-but-not-FROM] >>> ***/

static asn_per_constraints_t asn_PER_type_SIZE_but_not_FROM_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 2,  2,  1,  4 }	/* (SIZE(1..4)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [SIZE-but-not-FROM] >>> ***/

static const ber_tlv_tag_t asn_DEF_SIZE_but_not_FROM_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SIZE_but_not_FROM = {
	"SIZE-but-not-FROM",
	"SIZE-but-not-FROM",
	&asn_OP_IA5String,
	SIZE_but_not_FROM_constraint,
	asn_DEF_SIZE_but_not_FROM_tags_1,
	sizeof(asn_DEF_SIZE_but_not_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_but_not_FROM_tags_1[0]), /* 1 */
	asn_DEF_SIZE_but_not_FROM_tags_1,	/* Same as above */
	sizeof(asn_DEF_SIZE_but_not_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_but_not_FROM_tags_1[0]), /* 1 */
	&asn_PER_type_SIZE_but_not_FROM_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SIZE-and-FROM] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [SIZE-and-FROM] >>> ***/

typedef PER_Visible_t	 SIZE_and_FROM_t;

/*** <<< FUNC-DECLS [SIZE-and-FROM] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SIZE_and_FROM;
asn_struct_free_f SIZE_and_FROM_free;
asn_struct_print_f SIZE_and_FROM_print;
asn_constr_check_f SIZE_and_FROM_constraint;
ber_type_decoder_f SIZE_and_FROM_decode_ber;
der_type_encoder_f SIZE_and_FROM_encode_der;
xer_type_decoder_f SIZE_and_FROM_decode_xer;
xer_type_encoder_f SIZE_and_FROM_encode_xer;
per_type_decoder_f SIZE_and_FROM_decode_uper;
per_type_encoder_f SIZE_and_FROM_encode_uper;

/*** <<< CTABLES [SIZE-and-FROM] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 68)) return -1;
	}
	return 0;
}


/*** <<< CODE [SIZE-and-FROM] >>> ***/

int
SIZE_and_FROM_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 4)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [SIZE-and-FROM] >>> ***/

static asn_per_constraints_t asn_PER_type_SIZE_and_FROM_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  65,  68 }	/* (65..68) */,
	{ APC_CONSTRAINED,	 2,  2,  1,  4 }	/* (SIZE(1..4)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [SIZE-and-FROM] >>> ***/

static const ber_tlv_tag_t asn_DEF_SIZE_and_FROM_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SIZE_and_FROM = {
	"SIZE-and-FROM",
	"SIZE-and-FROM",
	&asn_OP_IA5String,
	SIZE_and_FROM_constraint,
	asn_DEF_SIZE_and_FROM_tags_1,
	sizeof(asn_DEF_SIZE_and_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_and_FROM_tags_1[0]), /* 1 */
	asn_DEF_SIZE_and_FROM_tags_1,	/* Same as above */
	sizeof(asn_DEF_SIZE_and_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_and_FROM_tags_1[0]), /* 1 */
	&asn_PER_type_SIZE_and_FROM_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Neither-SIZE-nor-FROM] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Neither-SIZE-nor-FROM] >>> ***/

typedef PER_Visible_t	 Neither_SIZE_nor_FROM_t;

/*** <<< FUNC-DECLS [Neither-SIZE-nor-FROM] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Neither_SIZE_nor_FROM;
asn_struct_free_f Neither_SIZE_nor_FROM_free;
asn_struct_print_f Neither_SIZE_nor_FROM_print;
asn_constr_check_f Neither_SIZE_nor_FROM_constraint;
ber_type_decoder_f Neither_SIZE_nor_FROM_decode_ber;
der_type_encoder_f Neither_SIZE_nor_FROM_encode_der;
xer_type_decoder_f Neither_SIZE_nor_FROM_decode_xer;
xer_type_encoder_f Neither_SIZE_nor_FROM_encode_xer;
per_type_decoder_f Neither_SIZE_nor_FROM_decode_uper;
per_type_encoder_f Neither_SIZE_nor_FROM_encode_uper;

/*** <<< CTABLES [Neither-SIZE-nor-FROM] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [Neither-SIZE-nor-FROM] >>> ***/

int
Neither_SIZE_nor_FROM_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Neither-SIZE-nor-FROM] >>> ***/

static asn_per_constraints_t asn_PER_type_Neither_SIZE_nor_FROM_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  70 }	/* (65..70) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};

/*** <<< STAT-DEFS [Neither-SIZE-nor-FROM] >>> ***/

static const ber_tlv_tag_t asn_DEF_Neither_SIZE_nor_FROM_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Neither_SIZE_nor_FROM = {
	"Neither-SIZE-nor-FROM",
	"Neither-SIZE-nor-FROM",
	&asn_OP_IA5String,
	Neither_SIZE_nor_FROM_constraint,
	asn_DEF_Neither_SIZE_nor_FROM_tags_1,
	sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1)
		/sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1[0]), /* 1 */
	asn_DEF_Neither_SIZE_nor_FROM_tags_1,	/* Same as above */
	sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1)
		/sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1[0]), /* 1 */
	&asn_PER_type_Neither_SIZE_nor_FROM_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-4] >>> ***/

#include <UTF8String.h>

/*** <<< TYPE-DECLS [Utf8-4] >>> ***/

typedef UTF8String_t	 Utf8_4_t;

/*** <<< FUNC-DECLS [Utf8-4] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_4;
asn_struct_free_f Utf8_4_free;
asn_struct_print_f Utf8_4_print;
asn_constr_check_f Utf8_4_constraint;
ber_type_decoder_f Utf8_4_decode_ber;
der_type_encoder_f Utf8_4_encode_der;
xer_type_decoder_f Utf8_4_decode_xer;
xer_type_encoder_f Utf8_4_encode_xer;
per_type_decoder_f Utf8_4_decode_uper;
per_type_encoder_f Utf8_4_encode_uper;

/*** <<< CTABLES [Utf8-4] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	if(UTF8String_length((const UTF8String_t *)sptr) < 0)
		return -1; /* Alphabet (sic!) test failed. */
	
	return 0;
}


/*** <<< CODE [Utf8-4] >>> ***/

int
Utf8_4_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using UTF8String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Utf8-4] >>> ***/

static asn_per_constraints_t asn_PER_type_Utf8_4_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Utf8-4] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_4_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_4 = {
	"Utf8-4",
	"Utf8-4",
	&asn_OP_UTF8String,
	Utf8_4_constraint,
	asn_DEF_Utf8_4_tags_1,
	sizeof(asn_DEF_Utf8_4_tags_1)
		/sizeof(asn_DEF_Utf8_4_tags_1[0]), /* 1 */
	asn_DEF_Utf8_4_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_4_tags_1)
		/sizeof(asn_DEF_Utf8_4_tags_1[0]), /* 1 */
	&asn_PER_type_Utf8_4_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-3] >>> ***/

#include "Utf8-2.h"

/*** <<< TYPE-DECLS [Utf8-3] >>> ***/

typedef Utf8_2_t	 Utf8_3_t;

/*** <<< FUNC-DECLS [Utf8-3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_3;
asn_struct_free_f Utf8_3_free;
asn_struct_print_f Utf8_3_print;
asn_constr_check_f Utf8_3_constraint;
ber_type_decoder_f Utf8_3_decode_ber;
der_type_encoder_f Utf8_3_encode_der;
xer_type_decoder_f Utf8_3_decode_xer;
xer_type_encoder_f Utf8_3_encode_xer;
per_type_decoder_f Utf8_3_decode_uper;
per_type_encoder_f Utf8_3_encode_uper;

/*** <<< CTABLES [Utf8-3] >>> ***/

static const int permitted_alphabet_table_1[128] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,	/*  ABCDEFGHIJKLMNO */
16,17,18,19,20,21,22,23,24,25,26, 0, 0, 0, 0, 0,	/* PQRSTUVWXYZ      */
 0,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,	/*  abcdefghijklmno */
42,43,44,45,46,47,48,49,50,51,52, 0, 0, 0, 0, 0,	/* pqrstuvwxyz      */
};

static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is UTF8String */
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(cv >= 0x80) return -1;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [Utf8-3] >>> ***/

int
Utf8_3_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Utf8_2_t *st = (const Utf8_2_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = UTF8String_length(st);
	if((ssize_t)size < 0) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: UTF-8: broken encoding (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((size >= 1 && size <= 2)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Utf8_2,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Utf8-3] >>> ***/

static asn_per_constraints_t asn_PER_type_Utf8_3_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Utf8-3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_3 = {
	"Utf8-3",
	"Utf8-3",
	&asn_OP_UTF8String,
	Utf8_3_constraint,
	asn_DEF_Utf8_3_tags_1,
	sizeof(asn_DEF_Utf8_3_tags_1)
		/sizeof(asn_DEF_Utf8_3_tags_1[0]), /* 1 */
	asn_DEF_Utf8_3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_3_tags_1)
		/sizeof(asn_DEF_Utf8_3_tags_1[0]), /* 1 */
	&asn_PER_type_Utf8_3_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-2] >>> ***/

#include "Utf8-1.h"

/*** <<< TYPE-DECLS [Utf8-2] >>> ***/

typedef Utf8_1_t	 Utf8_2_t;

/*** <<< FUNC-DECLS [Utf8-2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_2;
asn_struct_free_f Utf8_2_free;
asn_struct_print_f Utf8_2_print;
asn_constr_check_f Utf8_2_constraint;
ber_type_decoder_f Utf8_2_decode_ber;
der_type_encoder_f Utf8_2_encode_der;
xer_type_decoder_f Utf8_2_decode_xer;
xer_type_encoder_f Utf8_2_encode_xer;
per_type_decoder_f Utf8_2_decode_uper;
per_type_encoder_f Utf8_2_encode_uper;

/*** <<< CODE [Utf8-2] >>> ***/

int
Utf8_2_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Utf8_1_t *st = (const Utf8_1_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = UTF8String_length(st);
	if((ssize_t)size < 0) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: UTF-8: broken encoding (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((size >= 1 && size <= 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Utf8_1,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Utf8-2] >>> ***/

static asn_per_constraints_t asn_PER_type_Utf8_2_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Utf8-2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_2 = {
	"Utf8-2",
	"Utf8-2",
	&asn_OP_UTF8String,
	Utf8_2_constraint,
	asn_DEF_Utf8_2_tags_1,
	sizeof(asn_DEF_Utf8_2_tags_1)
		/sizeof(asn_DEF_Utf8_2_tags_1[0]), /* 1 */
	asn_DEF_Utf8_2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_2_tags_1)
		/sizeof(asn_DEF_Utf8_2_tags_1[0]), /* 1 */
	&asn_PER_type_Utf8_2_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-1] >>> ***/

#include <UTF8String.h>

/*** <<< TYPE-DECLS [Utf8-1] >>> ***/

typedef UTF8String_t	 Utf8_1_t;

/*** <<< FUNC-DECLS [Utf8-1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_1;
asn_struct_free_f Utf8_1_free;
asn_struct_print_f Utf8_1_print;
asn_constr_check_f Utf8_1_constraint;
ber_type_decoder_f Utf8_1_decode_ber;
der_type_encoder_f Utf8_1_encode_der;
xer_type_decoder_f Utf8_1_decode_xer;
xer_type_encoder_f Utf8_1_encode_xer;
per_type_decoder_f Utf8_1_decode_uper;
per_type_encoder_f Utf8_1_encode_uper;

/*** <<< CODE [Utf8-1] >>> ***/

/*
 * This type is implemented using UTF8String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Utf8-1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_1 = {
	"Utf8-1",
	"Utf8-1",
	&asn_OP_UTF8String,
	UTF8String_constraint,
	asn_DEF_Utf8_1_tags_1,
	sizeof(asn_DEF_Utf8_1_tags_1)
		/sizeof(asn_DEF_Utf8_1_tags_1[0]), /* 1 */
	asn_DEF_Utf8_1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_1_tags_1)
		/sizeof(asn_DEF_Utf8_1_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VisibleIdentifier] >>> ***/

#include "Identifier.h"

/*** <<< TYPE-DECLS [VisibleIdentifier] >>> ***/

typedef Identifier_t	 VisibleIdentifier_t;

/*** <<< FUNC-DECLS [VisibleIdentifier] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VisibleIdentifier;
asn_struct_free_f VisibleIdentifier_free;
asn_struct_print_f VisibleIdentifier_print;
asn_constr_check_f VisibleIdentifier_constraint;
ber_type_decoder_f VisibleIdentifier_decode_ber;
der_type_encoder_f VisibleIdentifier_encode_der;
xer_type_decoder_f VisibleIdentifier_decode_xer;
xer_type_encoder_f VisibleIdentifier_encode_xer;
per_type_decoder_f VisibleIdentifier_decode_uper;
per_type_encoder_f VisibleIdentifier_encode_uper;

/*** <<< CTABLES [VisibleIdentifier] >>> ***/

static const int permitted_alphabet_table_1[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*     $            */
 2, 3, 4, 5, 6, 7, 8, 9,10,11, 0, 0, 0, 0, 0, 0,	/* 0123456789       */
 0,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,	/*  ABCDEFGHIJKLMNO */
27,28,29,30,31,32,33,34,35,36,37, 0, 0, 0, 0,38,	/* PQRSTUVWXYZ    _ */
 0,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,	/*  abcdefghijklmno */
54,55,56,57,58,59,60,61,62,63,64, 0, 0, 0, 0, 0,	/* pqrstuvwxyz      */
};
static const int permitted_alphabet_code2value_1[64] = {
36,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,
70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,
86,87,88,89,90,95,97,98,99,100,101,102,103,104,105,106,
107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,
};


static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [VisibleIdentifier] >>> ***/

int
VisibleIdentifier_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Identifier_t *st = (const Identifier_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 32)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Identifier,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [VisibleIdentifier] >>> ***/

static const ber_tlv_tag_t asn_DEF_VisibleIdentifier_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (26 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VisibleIdentifier = {
	"VisibleIdentifier",
	"VisibleIdentifier",
	&asn_OP_VisibleString,
	VisibleIdentifier_constraint,
	asn_DEF_VisibleIdentifier_tags_1,
	sizeof(asn_DEF_VisibleIdentifier_tags_1)
		/sizeof(asn_DEF_VisibleIdentifier_tags_1[0]), /* 1 */
	asn_DEF_VisibleIdentifier_tags_1,	/* Same as above */
	sizeof(asn_DEF_VisibleIdentifier_tags_1)
		/sizeof(asn_DEF_VisibleIdentifier_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Sequence] >>> ***/

#include "Int1.h"
#include "Int4.h"
#include <BOOLEAN.h>
#include <NativeEnumerated.h>
#include <NULL.h>
#include "Int5.h"
#include <constr_SEQUENCE.h>

/*** <<< DEPS [Sequence] >>> ***/

typedef enum enum_c {
	enum_c_one	= 1,
	enum_c_two	= 2,
	/*
	 * Enumeration is extensible
	 */
	enum_c_three	= 3
} e_enum_c;

/*** <<< TYPE-DECLS [Sequence] >>> ***/

typedef struct Sequence {
	Int1_t	*int1_c	/* DEFAULT 3 */;
	Int4_t	 int4;
	Int4_t	 int4_c;
	BOOLEAN_t	*Bool	/* DEFAULT 1 */;
	long	 enum_c;
	NULL_t	*null	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	Int5_t	*int5_c	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Sequence_t;

/*** <<< FUNC-DECLS [Sequence] >>> ***/

/* extern asn_TYPE_descriptor_t asn_DEF_enum_c_6;	// (Use -fall-defs-global to expose) */
extern asn_TYPE_descriptor_t asn_DEF_Sequence;
extern asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1;
extern asn_TYPE_member_t asn_MBR_Sequence_1[7];

/*** <<< CODE [Sequence] >>> ***/

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */
static int
memb_int1_c_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= -2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_int4_c_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 5 && value <= 7)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_int5_c_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value == 5)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< CTDEFS [Sequence] >>> ***/

static asn_per_constraints_t asn_PER_type_enum_c_constr_6 GCC_NOTUSED = {
	{ APC_CONSTRAINED | APC_EXTENSIBLE,  1,  1,  0,  1 }	/* (0..1,...) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_int1_c_constr_2 GCC_NOTUSED = {
	{ APC_SEMI_CONSTRAINED,	-1, -1, -2,  0 }	/* (-2..MAX) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_int4_c_constr_4 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  5,  7 }	/* (5..7) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_int5_c_constr_13 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 0,  0,  5,  5 }	/* (5..5) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Sequence] >>> ***/

static int asn_DFL_2_set_3(int set_value, void **sptr) {
	Int1_t *st = *sptr;
	
	if(!st) {
		if(!set_value) return -1;	/* Not a default value */
		st = (*sptr = CALLOC(1, sizeof(*st)));
		if(!st) return -1;
	}
	
	if(set_value) {
		/* Install default value 3 */
		*st = 3;
		return 0;
	} else {
		/* Test default value 3 */
		return (*st == 3);
	}
}
static int asn_DFL_5_set_1(int set_value, void **sptr) {
	BOOLEAN_t *st = *sptr;
	
	if(!st) {
		if(!set_value) return -1;	/* Not a default value */
		st = (*sptr = CALLOC(1, sizeof(*st)));
		if(!st) return -1;
	}
	
	if(set_value) {
		/* Install default value 1 */
		*st = 1;
		return 0;
	} else {
		/* Test default value 1 */
		return (*st == 1);
	}
}
static const asn_INTEGER_enum_map_t asn_MAP_enum_c_value2enum_6[] = {
	{ 1,	3,	"one" },
	{ 2,	3,	"two" },
	{ 3,	5,	"three" }
	/* This list is extensible */
};
static const unsigned int asn_MAP_enum_c_enum2value_6[] = {
	0,	/* one(1) */
	2,	/* three(3) */
	1	/* two(2) */
	/* This list is extensible */
};
static const asn_INTEGER_specifics_t asn_SPC_enum_c_specs_6 = {
	asn_MAP_enum_c_value2enum_6,	/* "tag" => N; sorted by tag */
	asn_MAP_enum_c_enum2value_6,	/* N => "tag"; sorted by N */
	3,	/* Number of elements in the maps */
	3,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_enum_c_tags_6[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_enum_c_6 = {
	"enum-c",
	"enum-c",
	&asn_OP_NativeEnumerated,
	NativeEnumerated_constraint,
	asn_DEF_enum_c_tags_6,
	sizeof(asn_DEF_enum_c_tags_6)
		/sizeof(asn_DEF_enum_c_tags_6[0]), /* 1 */
	asn_DEF_enum_c_tags_6,	/* Same as above */
	sizeof(asn_DEF_enum_c_tags_6)
		/sizeof(asn_DEF_enum_c_tags_6[0]), /* 1 */
	&asn_PER_type_enum_c_constr_6,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_enum_c_specs_6	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_Sequence_1[] = {
	{ ATF_POINTER, 1, offsetof(struct Sequence, int1_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Int1,
		.memb_constraints = memb_int1_c_constraint_1,
		.per_constraints = &asn_PER_memb_int1_c_constr_2,
		.default_value = asn_DFL_2_set_3,	/* DEFAULT 3 */
		.name = "int1-c"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, int4),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_Int4,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* No PER visible constraints */
		.default_value = 0,
		.name = "int4"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, int4_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Int4,
		.memb_constraints = memb_int4_c_constraint_1,
		.per_constraints = &asn_PER_memb_int4_c_constr_4,
		.default_value = 0,
		.name = "int4-c"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, Bool),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (1 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_BOOLEAN,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* No PER visible constraints */
		.default_value = asn_DFL_5_set_1,	/* DEFAULT 1 */
		.name = "bool"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, enum_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_enum_c_6,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* No PER visible constraints */
		.default_value = 0,
		.name = "enum-c"
		},
	{ ATF_POINTER, 2, offsetof(struct Sequence, null),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_NULL,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* No PER visible constraints */
		.default_value = 0,
		.name = "null"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, int5_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Int5,
		.memb_constraints = memb_int5_c_constraint_1,
		.per_constraints = &asn_PER_memb_int5_c_constr_13,
		.default_value = 0,
		.name = "int5-c"
		},
};
static const int asn_MAP_Sequence_oms_1[] = { 0, 3, 5, 6 };
static const ber_tlv_tag_t asn_DEF_Sequence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_Sequence_tag2el_1[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (1 << 2)), 3, 0, 0 }, /* bool */
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 2 }, /* int1-c */
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 2, -1, 1 }, /* int4-c */
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 6, -2, 0 }, /* int5-c */
    { (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)), 5, 0, 0 }, /* null */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 4, 0, 0 }, /* enum-c */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 1, 0, 0 } /* int4 */
};
asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1 = {
	sizeof(struct Sequence),
	offsetof(struct Sequence, _asn_ctx),
	asn_MAP_Sequence_tag2el_1,
	7,	/* Count of tags in the map */
	asn_MAP_Sequence_oms_1,	/* Optional members */
	3, 1,	/* Root/Additions */
	5,	/* Start extensions */
	8	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Sequence = {
	"Sequence",
	"Sequence",
	&asn_OP_SEQUENCE,
	SEQUENCE_constraint,
	asn_DEF_Sequence_tags_1,
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	asn_DEF_Sequence_tags_1,	/* Same as above */
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Sequence_1,
	7,	/* Elements count */
	&asn_SPC_Sequence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SequenceOf] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< FWD-DECLS [SequenceOf] >>> ***/

struct Sequence;

/*** <<< TYPE-DECLS [SequenceOf] >>> ***/

typedef struct SequenceOf {
	A_SEQUENCE_OF(struct Sequence) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SequenceOf_t;

/*** <<< FUNC-DECLS [SequenceOf] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SequenceOf;

/*** <<< POST-INCLUDE [SequenceOf] >>> ***/

#include "Sequence.h"

/*** <<< CTDEFS [SequenceOf] >>> ***/

static asn_per_constraints_t asn_PER_type_SequenceOf_constr_1 GCC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_CONSTRAINED,	 1,  1,  1,  2 }	/* (SIZE(1..2)) */,
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [SequenceOf] >>> ***/

static asn_TYPE_member_t asn_MBR_SequenceOf_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Sequence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* No PER visible constraints */
		.default_value = 0,
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_SequenceOf_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_SequenceOf_specs_1 = {
	sizeof(struct SequenceOf),
	offsetof(struct SequenceOf, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_SequenceOf = {
	"SequenceOf",
	"SequenceOf",
	&asn_OP_SEQUENCE_OF,
	SEQUENCE_OF_constraint,
	asn_DEF_SequenceOf_tags_1,
	sizeof(asn_DEF_SequenceOf_tags_1)
		/sizeof(asn_DEF_SequenceOf_tags_1[0]), /* 1 */
	asn_DEF_SequenceOf_tags_1,	/* Same as above */
	sizeof(asn_DEF_SequenceOf_tags_1)
		/sizeof(asn_DEF_SequenceOf_tags_1[0]), /* 1 */
	&asn_PER_type_SequenceOf_constr_1,
	asn_MBR_SequenceOf_1,
	1,	/* Single element */
	&asn_SPC_SequenceOf_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Enum0] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [Enum0] >>> ***/

typedef enum Enum0 {
	Enum0_one	= 0,
	Enum0_two	= 1
} e_Enum0;

/*** <<< TYPE-DECLS [Enum0] >>> ***/

typedef long	 Enum0_t;

/*** <<< FUNC-DECLS [Enum0] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Enum0;
asn_struct_free_f Enum0_free;
asn_struct_print_f Enum0_print;
asn_constr_check_f Enum0_constraint;
ber_type_decoder_f Enum0_decode_ber;
der_type_encoder_f Enum0_encode_der;
xer_type_decoder_f Enum0_decode_xer;
xer_type_encoder_f Enum0_encode_xer;
per_type_decoder_f Enum0_decode_uper;
per_type_encoder_f Enum0_encode_uper;

/*** <<< CODE [Enum0] >>> ***/

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Enum0] >>> ***/

static asn_per_constraints_t asn_PER_type_Enum0_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Enum0] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_Enum0_value2enum_1[] = {
	{ 0,	3,	"one" },
	{ 1,	3,	"two" }
};
static const unsigned int asn_MAP_Enum0_enum2value_1[] = {
	0,	/* one(0) */
	1	/* two(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_Enum0_specs_1 = {
	asn_MAP_Enum0_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Enum0_enum2value_1,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_Enum0_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Enum0 = {
	"Enum0",
	"Enum0",
	&asn_OP_NativeEnumerated,
	NativeEnumerated_constraint,
	asn_DEF_Enum0_tags_1,
	sizeof(asn_DEF_Enum0_tags_1)
		/sizeof(asn_DEF_Enum0_tags_1[0]), /* 1 */
	asn_DEF_Enum0_tags_1,	/* Same as above */
	sizeof(asn_DEF_Enum0_tags_1)
		/sizeof(asn_DEF_Enum0_tags_1[0]), /* 1 */
	&asn_PER_type_Enum0_constr_1,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Enum0_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Enum1] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [Enum1] >>> ***/

typedef enum Enum1 {
	Enum1_one	= 0,
	Enum1_two	= 1
} e_Enum1;

/*** <<< TYPE-DECLS [Enum1] >>> ***/

typedef long	 Enum1_t;

/*** <<< FUNC-DECLS [Enum1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Enum1;
asn_struct_free_f Enum1_free;
asn_struct_print_f Enum1_print;
asn_constr_check_f Enum1_constraint;
ber_type_decoder_f Enum1_decode_ber;
der_type_encoder_f Enum1_encode_der;
xer_type_decoder_f Enum1_decode_xer;
xer_type_encoder_f Enum1_encode_xer;
per_type_decoder_f Enum1_decode_uper;
per_type_encoder_f Enum1_encode_uper;

/*** <<< CODE [Enum1] >>> ***/

int
Enum1_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value == 0)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Enum1] >>> ***/

static asn_per_constraints_t asn_PER_type_Enum1_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  0,  1 }	/* (0..1) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};

/*** <<< STAT-DEFS [Enum1] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_Enum1_value2enum_1[] = {
	{ 0,	3,	"one" },
	{ 1,	3,	"two" }
};
static const unsigned int asn_MAP_Enum1_enum2value_1[] = {
	0,	/* one(0) */
	1	/* two(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_Enum1_specs_1 = {
	asn_MAP_Enum1_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Enum1_enum2value_1,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_Enum1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Enum1 = {
	"Enum1",
	"Enum1",
	&asn_OP_NativeEnumerated,
	Enum1_constraint,
	asn_DEF_Enum1_tags_1,
	sizeof(asn_DEF_Enum1_tags_1)
		/sizeof(asn_DEF_Enum1_tags_1[0]), /* 1 */
	asn_DEF_Enum1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Enum1_tags_1)
		/sizeof(asn_DEF_Enum1_tags_1[0]), /* 1 */
	&asn_PER_type_Enum1_constr_1,
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Enum1_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Identifier] >>> ***/

#include <VisibleString.h>

/*** <<< TYPE-DECLS [Identifier] >>> ***/

typedef VisibleString_t	 Identifier_t;

/*** <<< FUNC-DECLS [Identifier] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Identifier;
asn_struct_free_f Identifier_free;
asn_struct_print_f Identifier_print;
asn_constr_check_f Identifier_constraint;
ber_type_decoder_f Identifier_decode_ber;
der_type_encoder_f Identifier_encode_der;
xer_type_decoder_f Identifier_decode_xer;
xer_type_encoder_f Identifier_encode_xer;
per_type_decoder_f Identifier_decode_uper;
per_type_encoder_f Identifier_encode_uper;

/*** <<< CTABLES [Identifier] >>> ***/

static const int permitted_alphabet_table_1[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*     $            */
 2, 3, 4, 5, 6, 7, 8, 9,10,11, 0, 0, 0, 0, 0, 0,	/* 0123456789       */
 0,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,	/*  ABCDEFGHIJKLMNO */
27,28,29,30,31,32,33,34,35,36,37, 0, 0, 0, 0,38,	/* PQRSTUVWXYZ    _ */
 0,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,	/*  abcdefghijklmno */
54,55,56,57,58,59,60,61,62,63,64, 0, 0, 0, 0, 0,	/* pqrstuvwxyz      */
};
static const int permitted_alphabet_code2value_1[64] = {
36,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,
70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,
86,87,88,89,90,95,97,98,99,100,101,102,103,104,105,106,
107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,
};


static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [Identifier] >>> ***/

int
Identifier_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 32)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_Identifier_1_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_1)/sizeof(permitted_alphabet_table_1[0]))
		return -1;
	return permitted_alphabet_table_1[value] - 1;
}
static int asn_PER_MAP_Identifier_1_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_1)/sizeof(permitted_alphabet_code2value_1[0]))
		return -1;
	return permitted_alphabet_code2value_1[code];
}
/*
 * This type is implemented using VisibleString,
 * so here we adjust the DEF accordingly.
 */

/*** <<< CTDEFS [Identifier] >>> ***/

static asn_per_constraints_t asn_PER_type_Identifier_constr_1 GCC_NOTUSED = {
	{ APC_CONSTRAINED,	 6,  6,  36,  122 }	/* (36..122) */,
	{ APC_CONSTRAINED,	 5,  5,  1,  32 }	/* (SIZE(1..32)) */,
	asn_PER_MAP_Identifier_1_v2c,	/* Value to PER code map */
	asn_PER_MAP_Identifier_1_c2v	/* PER code to value map */
};

/*** <<< STAT-DEFS [Identifier] >>> ***/

static const ber_tlv_tag_t asn_DEF_Identifier_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (26 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Identifier = {
	"Identifier",
	"Identifier",
	&asn_OP_VisibleString,
	Identifier_constraint,
	asn_DEF_Identifier_tags_1,
	sizeof(asn_DEF_Identifier_tags_1)
		/sizeof(asn_DEF_Identifier_tags_1[0]), /* 1 */
	asn_DEF_Identifier_tags_1,	/* Same as above */
	sizeof(asn_DEF_Identifier_tags_1)
		/sizeof(asn_DEF_Identifier_tags_1[0]), /* 1 */
	&asn_PER_type_Identifier_constr_1,
	0, 0,	/* No members */
	0	/* No specifics */
};

