
/*** <<< INCLUDES [Everything] >>> ***/

#include "Set.h"
#include "Alpha.h"
#include "Beta.h"
#include "Gamma.h"
#include "OneTwo.h"
#include "TwoThree.h"
#include "ThreeOne.h"
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Everything] >>> ***/

struct Choice1;
struct Choice2;
struct Choice3;

/*** <<< TYPE-DECLS [Everything] >>> ***/

typedef struct Everything {
	struct Choice1	*ch1;
	struct Choice2	*ch2;
	struct Choice3	*ch3;
	Set_t	 set;
	Alpha_t	 a;
	Beta_t	 b;
	Gamma_t	 g;
	OneTwo_t	 ot;
	TwoThree_t	 tt;
	ThreeOne_t	 to;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Everything_t;

/*** <<< FUNC-DECLS [Everything] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Everything;

/*** <<< POST-INCLUDE [Everything] >>> ***/

#include "Choice1.h"
#include "Choice2.h"
#include "Choice3.h"

/*** <<< STAT-DEFS [Everything] >>> ***/

static asn_TYPE_member_t asn_MBR_Everything_1[] = {
	{ ATF_POINTER, 0, offsetof(struct Everything, ch1),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_Choice1,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "ch1"
		},
	{ ATF_POINTER, 0, offsetof(struct Everything, ch2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_Choice2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "ch2"
		},
	{ ATF_POINTER, 0, offsetof(struct Everything, ch3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_Choice3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "ch3"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "set"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Alpha,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "a"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Beta,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, g),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Gamma,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "g"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, ot),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OneTwo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "ot"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, tt),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TwoThree,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "tt"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Everything, to),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ThreeOne,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "to"
		},
};
static ber_tlv_tag_t asn_DEF_Everything_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Everything_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* ch1 at 15 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* ch2 at 16 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* ch3 at 17 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* set at 18 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* a at 19 */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* b at 20 */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* g at 21 */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* ot at 22 */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* tt at 23 */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 } /* to at 25 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Everything_specs_1 = {
	sizeof(struct Everything),
	offsetof(struct Everything, _asn_ctx),
	asn_MAP_Everything_tag2el_1,
	10,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Everything = {
	"Everything",
	"Everything",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Everything_tags_1,
	sizeof(asn_DEF_Everything_tags_1)
		/sizeof(asn_DEF_Everything_tags_1[0]), /* 1 */
	asn_DEF_Everything_tags_1,	/* Same as above */
	sizeof(asn_DEF_Everything_tags_1)
		/sizeof(asn_DEF_Everything_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Everything_1,
	10,	/* Elements count */
	&asn_SPC_Everything_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Choice1] >>> ***/

#include <constr_CHOICE.h>

/*** <<< DEPS [Choice1] >>> ***/

typedef enum Choice1_PR {
	Choice1_PR_NOTHING,	/* No components present */
	Choice1_PR_something,
	/* Extensions may appear below */
	Choice1_PR_some2
} Choice1_PR;

/*** <<< FWD-DECLS [Choice1] >>> ***/

struct Everything;

/*** <<< TYPE-DECLS [Choice1] >>> ***/

typedef struct Choice1 {
	Choice1_PR present;
	union Choice1_u {
		struct Everything	*something;
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
		struct Everything	*some2;
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Choice1_t;

/*** <<< FUNC-DECLS [Choice1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Choice1;

/*** <<< POST-INCLUDE [Choice1] >>> ***/

#include "Everything.h"

/*** <<< STAT-DEFS [Choice1] >>> ***/

static asn_TYPE_member_t asn_MBR_Choice1_1[] = {
	{ ATF_POINTER, 0, offsetof(struct Choice1, choice.something),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "something"
		},
	{ ATF_POINTER, 0, offsetof(struct Choice1, choice.some2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "some2"
		},
};
static asn_TYPE_tag2member_t asn_MAP_Choice1_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* something at 29 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* some2 at 32 */
};
static asn_CHOICE_specifics_t asn_SPC_Choice1_specs_1 = {
	sizeof(struct Choice1),
	offsetof(struct Choice1, _asn_ctx),
	offsetof(struct Choice1, present),
	sizeof(((struct Choice1 *)0)->present),
	asn_MAP_Choice1_tag2el_1,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = 1	/* Extensions start */
};
asn_TYPE_descriptor_t asn_DEF_Choice1 = {
	"Choice1",
	"Choice1",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_Choice1_1,
	2,	/* Elements count */
	&asn_SPC_Choice1_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Choice2] >>> ***/

#include "TypeRef.h"
#include <constr_CHOICE.h>

/*** <<< DEPS [Choice2] >>> ***/

typedef enum Choice2_PR {
	Choice2_PR_NOTHING,	/* No components present */
	Choice2_PR_typeref,
	/* Extensions may appear below */
	Choice2_PR_some3
} Choice2_PR;

/*** <<< FWD-DECLS [Choice2] >>> ***/

struct Everything;

/*** <<< TYPE-DECLS [Choice2] >>> ***/

typedef struct Choice2 {
	Choice2_PR present;
	union Choice2_u {
		TypeRef_t	 typeref;
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
		struct Everything	*some3;
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Choice2_t;

/*** <<< FUNC-DECLS [Choice2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Choice2;

/*** <<< POST-INCLUDE [Choice2] >>> ***/

#include "Everything.h"

/*** <<< STAT-DEFS [Choice2] >>> ***/

static asn_TYPE_member_t asn_MBR_Choice2_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Choice2, choice.typeref),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TypeRef,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "typeref"
		},
	{ ATF_POINTER, 0, offsetof(struct Choice2, choice.some3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "some3"
		},
};
static asn_TYPE_tag2member_t asn_MAP_Choice2_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* typeref at 35 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* some3 at 38 */
};
static asn_CHOICE_specifics_t asn_SPC_Choice2_specs_1 = {
	sizeof(struct Choice2),
	offsetof(struct Choice2, _asn_ctx),
	offsetof(struct Choice2, present),
	sizeof(((struct Choice2 *)0)->present),
	asn_MAP_Choice2_tag2el_1,
	2,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = 1	/* Extensions start */
};
asn_TYPE_descriptor_t asn_DEF_Choice2 = {
	"Choice2",
	"Choice2",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_Choice2_1,
	2,	/* Elements count */
	&asn_SPC_Choice2_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Choice3] >>> ***/

#include <constr_SEQUENCE.h>
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_CHOICE.h>

/*** <<< DEPS [Choice3] >>> ***/

typedef enum Choice3_PR {
	Choice3_PR_NOTHING,	/* No components present */
	Choice3_PR_a,
	Choice3_PR_b,
	Choice3_PR_c
} Choice3_PR;

/*** <<< FWD-DECLS [Choice3] >>> ***/

struct Everything;
struct Choice3;

/*** <<< TYPE-DECLS [Choice3] >>> ***/

typedef struct Choice3 {
	Choice3_PR present;
	union Choice3_u {
		struct a {
			struct Everything	*aa;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} a;
		struct Everything	*b;
		struct c {
			A_SEQUENCE_OF(struct Choice3) list;
			
			/* Context for parsing across buffer boundaries */
			asn_struct_ctx_t _asn_ctx;
		} c;
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Choice3_t;

/*** <<< FUNC-DECLS [Choice3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Choice3;

/*** <<< POST-INCLUDE [Choice3] >>> ***/

#include "Everything.h"
#include "Choice3.h"

/*** <<< STAT-DEFS [Choice3] >>> ***/

static asn_TYPE_member_t asn_MBR_a_2[] = {
	{ ATF_POINTER, 0, offsetof(struct a, aa),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "aa"
		},
};
static ber_tlv_tag_t asn_DEF_a_tags_2[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_a_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* aa at 43 */
};
static asn_SEQUENCE_specifics_t asn_SPC_a_specs_2 = {
	sizeof(struct a),
	offsetof(struct a, _asn_ctx),
	asn_MAP_a_tag2el_2,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_a_2 = {
	"a",
	"a",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_a_tags_2,
	sizeof(asn_DEF_a_tags_2)
		/sizeof(asn_DEF_a_tags_2[0]) - 1, /* 1 */
	asn_DEF_a_tags_2,	/* Same as above */
	sizeof(asn_DEF_a_tags_2)
		/sizeof(asn_DEF_a_tags_2[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_a_2,
	1,	/* Elements count */
	&asn_SPC_a_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_c_5[] = {
	{ ATF_POINTER, 0, 0,
		.tag = -1 /* Ambiguous tag (CHOICE?) */,
		.tag_mode = 0,
		.type = &asn_DEF_Choice3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_c_tags_5[] = {
	(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_c_specs_5 = {
	sizeof(struct c),
	offsetof(struct c, _asn_ctx),
	2,	/* XER encoding is XMLValueList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_c_5 = {
	"c",
	"c",
	SEQUENCE_OF_free,
	SEQUENCE_OF_print,
	SEQUENCE_OF_constraint,
	SEQUENCE_OF_decode_ber,
	SEQUENCE_OF_encode_der,
	SEQUENCE_OF_decode_xer,
	SEQUENCE_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_c_tags_5,
	sizeof(asn_DEF_c_tags_5)
		/sizeof(asn_DEF_c_tags_5[0]) - 1, /* 1 */
	asn_DEF_c_tags_5,	/* Same as above */
	sizeof(asn_DEF_c_tags_5)
		/sizeof(asn_DEF_c_tags_5[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_c_5,
	1,	/* Single element */
	&asn_SPC_c_specs_5	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Choice3_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Choice3, choice.a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_a_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "a"
		},
	{ ATF_POINTER, 0, offsetof(struct Choice3, choice.b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Everything,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Choice3, choice.c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_c_5,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "c"
		},
};
static asn_TYPE_tag2member_t asn_MAP_Choice3_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* a at 43 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* b at 44 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* c at 46 */
};
static asn_CHOICE_specifics_t asn_SPC_Choice3_specs_1 = {
	sizeof(struct Choice3),
	offsetof(struct Choice3, _asn_ctx),
	offsetof(struct Choice3, present),
	sizeof(((struct Choice3 *)0)->present),
	asn_MAP_Choice3_tag2el_1,
	3,	/* Count of tags in the map */
	.canonical_order = 0,
	.ext_start = -1	/* Extensions start */
};
asn_TYPE_descriptor_t asn_DEF_Choice3 = {
	"Choice3",
	"Choice3",
	CHOICE_free,
	CHOICE_print,
	CHOICE_constraint,
	CHOICE_decode_ber,
	CHOICE_encode_der,
	CHOICE_decode_xer,
	CHOICE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	CHOICE_outmost_tag,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	0,	/* No PER visible constraints */
	asn_MBR_Choice3_1,
	3,	/* Elements count */
	&asn_SPC_Choice3_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Set] >>> ***/

#include <asn_SET_OF.h>
#include <INTEGER.h>
#include <constr_SEQUENCE.h>
#include <constr_SET_OF.h>

/*** <<< FWD-DECLS [Set] >>> ***/

struct Set;
struct Sequence;

/*** <<< TYPE-DECLS [Set] >>> ***/

typedef struct Set {
	A_SET_OF(struct Member {
		INTEGER_t	 Int;
		struct Set	*set;
		struct Sequence	*seq;
		struct Set	*set2	/* OPTIONAL */;
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
		struct Set	*set3;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} ) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Set_t;

/*** <<< FUNC-DECLS [Set] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Set;

/*** <<< POST-INCLUDE [Set] >>> ***/

#include "Set.h"
#include "Sequence.h"

/*** <<< STAT-DEFS [Set] >>> ***/

static asn_TYPE_member_t asn_MBR_Member_2[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Member, Int),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "int"
		},
	{ ATF_POINTER, 0, offsetof(struct Member, set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "set"
		},
	{ ATF_POINTER, 0, offsetof(struct Member, seq),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Sequence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "seq"
		},
	{ ATF_POINTER, 2, offsetof(struct Member, set2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "set2"
		},
	{ ATF_POINTER, 1, offsetof(struct Member, set3),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "set3"
		},
};
static ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Member_tag2el_2[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* int at 49 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* set at 50 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* seq at 51 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* set2 at 52 */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 } /* set3 at 55 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Member_specs_2 = {
	sizeof(struct Member),
	offsetof(struct Member, _asn_ctx),
	asn_MAP_Member_tag2el_2,
	5,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	3,	/* Start extensions */
	6	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"SEQUENCE",
	"SEQUENCE",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Member_2,
	5,	/* Elements count */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Set_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = ""
		},
};
static ber_tlv_tag_t asn_DEF_Set_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_Set_specs_1 = {
	sizeof(struct Set),
	offsetof(struct Set, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_Set = {
	"Set",
	"Set",
	SET_OF_free,
	SET_OF_print,
	SET_OF_constraint,
	SET_OF_decode_ber,
	SET_OF_encode_der,
	SET_OF_decode_xer,
	SET_OF_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Set_tags_1,
	sizeof(asn_DEF_Set_tags_1)
		/sizeof(asn_DEF_Set_tags_1[0]), /* 1 */
	asn_DEF_Set_tags_1,	/* Same as above */
	sizeof(asn_DEF_Set_tags_1)
		/sizeof(asn_DEF_Set_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Set_1,
	1,	/* Single element */
	&asn_SPC_Set_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Sequence] >>> ***/

#include <INTEGER.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Sequence] >>> ***/

struct Sequence;
struct Set;

/*** <<< TYPE-DECLS [Sequence] >>> ***/

typedef struct Sequence {
	INTEGER_t	 a;
	struct Sequence	*seq	/* OPTIONAL */;
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	INTEGER_t	*b;
	struct Set	*set	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Sequence_t;

/*** <<< FUNC-DECLS [Sequence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Sequence;

/*** <<< POST-INCLUDE [Sequence] >>> ***/

#include "Sequence.h"
#include "Set.h"

/*** <<< STAT-DEFS [Sequence] >>> ***/

static asn_TYPE_member_t asn_MBR_Sequence_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "a"
		},
	{ ATF_POINTER, 3, offsetof(struct Sequence, seq),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Sequence,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "seq"
		},
	{ ATF_POINTER, 2, offsetof(struct Sequence, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Set,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "set"
		},
};
static ber_tlv_tag_t asn_DEF_Sequence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Sequence_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* a at 58 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* seq at 59 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* b at 61 */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* set at 62 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1 = {
	sizeof(struct Sequence),
	offsetof(struct Sequence, _asn_ctx),
	asn_MAP_Sequence_tag2el_1,
	4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	1,	/* Start extensions */
	5	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Sequence = {
	"Sequence",
	"Sequence",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Sequence_tags_1,
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	asn_DEF_Sequence_tags_1,	/* Same as above */
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Sequence_1,
	4,	/* Elements count */
	&asn_SPC_Sequence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TypeRef] >>> ***/

#include "Sequence.h"

/*** <<< TYPE-DECLS [TypeRef] >>> ***/

typedef Sequence_t	 TypeRef_t;

/*** <<< FUNC-DECLS [TypeRef] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TypeRef;
asn_struct_free_f TypeRef_free;
asn_struct_print_f TypeRef_print;
asn_constr_check_f TypeRef_constraint;
ber_type_decoder_f TypeRef_decode_ber;
der_type_encoder_f TypeRef_encode_der;
xer_type_decoder_f TypeRef_decode_xer;
xer_type_encoder_f TypeRef_encode_xer;

/*** <<< CODE [TypeRef] >>> ***/

int
TypeRef_constraint(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	/* Replace with underlying type checker */
	td->check_constraints = asn_DEF_Sequence.check_constraints;
	return td->check_constraints(td, sptr, ctfailcb, app_key);
}

/*
 * This type is implemented using Sequence,
 * so here we adjust the DEF accordingly.
 */
static void
TypeRef_1_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_Sequence.free_struct;
	td->print_struct   = asn_DEF_Sequence.print_struct;
	td->ber_decoder    = asn_DEF_Sequence.ber_decoder;
	td->der_encoder    = asn_DEF_Sequence.der_encoder;
	td->xer_decoder    = asn_DEF_Sequence.xer_decoder;
	td->xer_encoder    = asn_DEF_Sequence.xer_encoder;
	td->uper_decoder   = asn_DEF_Sequence.uper_decoder;
	td->uper_encoder   = asn_DEF_Sequence.uper_encoder;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_Sequence.per_constraints;
	td->elements       = asn_DEF_Sequence.elements;
	td->elements_count = asn_DEF_Sequence.elements_count;
	td->specifics      = asn_DEF_Sequence.specifics;
}

void
TypeRef_free(asn_TYPE_descriptor_t *td,
		void *struct_ptr, int contents_only) {
	TypeRef_1_inherit_TYPE_descriptor(td);
	td->free_struct(td, struct_ptr, contents_only);
}

int
TypeRef_print(asn_TYPE_descriptor_t *td, const void *struct_ptr,
		int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
	TypeRef_1_inherit_TYPE_descriptor(td);
	return td->print_struct(td, struct_ptr, ilevel, cb, app_key);
}

asn_dec_rval_t
TypeRef_decode_ber(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const void *bufptr, size_t size, int tag_mode) {
	TypeRef_1_inherit_TYPE_descriptor(td);
	return td->ber_decoder(opt_codec_ctx, td, structure, bufptr, size, tag_mode);
}

asn_enc_rval_t
TypeRef_encode_der(asn_TYPE_descriptor_t *td,
		void *structure, int tag_mode, ber_tlv_tag_t tag,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TypeRef_1_inherit_TYPE_descriptor(td);
	return td->der_encoder(td, structure, tag_mode, tag, cb, app_key);
}

asn_dec_rval_t
TypeRef_decode_xer(asn_codec_ctx_t *opt_codec_ctx, asn_TYPE_descriptor_t *td,
		void **structure, const char *opt_mname, const void *bufptr, size_t size) {
	TypeRef_1_inherit_TYPE_descriptor(td);
	return td->xer_decoder(opt_codec_ctx, td, structure, opt_mname, bufptr, size);
}

asn_enc_rval_t
TypeRef_encode_xer(asn_TYPE_descriptor_t *td, void *structure,
		int ilevel, enum xer_encoder_flags_e flags,
		asn_app_consume_bytes_f *cb, void *app_key) {
	TypeRef_1_inherit_TYPE_descriptor(td);
	return td->xer_encoder(td, structure, ilevel, flags, cb, app_key);
}


/*** <<< STAT-DEFS [TypeRef] >>> ***/

static ber_tlv_tag_t asn_DEF_TypeRef_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
asn_TYPE_descriptor_t asn_DEF_TypeRef = {
	"TypeRef",
	"TypeRef",
	TypeRef_free,
	TypeRef_print,
	TypeRef_constraint,
	TypeRef_decode_ber,
	TypeRef_encode_der,
	TypeRef_decode_xer,
	TypeRef_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TypeRef_tags_1,
	sizeof(asn_DEF_TypeRef_tags_1)
		/sizeof(asn_DEF_TypeRef_tags_1[0]), /* 1 */
	asn_DEF_TypeRef_tags_1,	/* Same as above */
	sizeof(asn_DEF_TypeRef_tags_1)
		/sizeof(asn_DEF_TypeRef_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	0, 0,	/* Defined elsewhere */
	0	/* No specifics */
};


/*** <<< INCLUDES [Alpha] >>> ***/

#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Alpha] >>> ***/

struct Beta;

/*** <<< TYPE-DECLS [Alpha] >>> ***/

typedef struct Alpha {
	struct Beta	*a;
	struct b {
		struct Beta	*b	/* OPTIONAL */;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} b;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Alpha_t;

/*** <<< FUNC-DECLS [Alpha] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Alpha;

/*** <<< POST-INCLUDE [Alpha] >>> ***/

#include "Beta.h"

/*** <<< STAT-DEFS [Alpha] >>> ***/

static asn_TYPE_member_t asn_MBR_b_3[] = {
	{ ATF_POINTER, 1, offsetof(struct b, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Beta,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
};
static ber_tlv_tag_t asn_DEF_b_tags_3[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_b_tag2el_3[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* b at 70 */
};
static asn_SEQUENCE_specifics_t asn_SPC_b_specs_3 = {
	sizeof(struct b),
	offsetof(struct b, _asn_ctx),
	asn_MAP_b_tag2el_3,
	1,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_b_3 = {
	"b",
	"b",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_b_tags_3,
	sizeof(asn_DEF_b_tags_3)
		/sizeof(asn_DEF_b_tags_3[0]) - 1, /* 1 */
	asn_DEF_b_tags_3,	/* Same as above */
	sizeof(asn_DEF_b_tags_3)
		/sizeof(asn_DEF_b_tags_3[0]), /* 2 */
	0,	/* No PER visible constraints */
	asn_MBR_b_3,
	1,	/* Elements count */
	&asn_SPC_b_specs_3	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_Alpha_1[] = {
	{ ATF_POINTER, 0, offsetof(struct Alpha, a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Beta,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "a"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Alpha, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_b_3,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
};
static ber_tlv_tag_t asn_DEF_Alpha_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Alpha_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* a at 68 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* b at 70 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Alpha_specs_1 = {
	sizeof(struct Alpha),
	offsetof(struct Alpha, _asn_ctx),
	asn_MAP_Alpha_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Alpha = {
	"Alpha",
	"Alpha",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Alpha_tags_1,
	sizeof(asn_DEF_Alpha_tags_1)
		/sizeof(asn_DEF_Alpha_tags_1[0]), /* 1 */
	asn_DEF_Alpha_tags_1,	/* Same as above */
	sizeof(asn_DEF_Alpha_tags_1)
		/sizeof(asn_DEF_Alpha_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Alpha_1,
	2,	/* Elements count */
	&asn_SPC_Alpha_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Beta] >>> ***/

#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Beta] >>> ***/

struct Alpha;
struct Gamma;

/*** <<< TYPE-DECLS [Beta] >>> ***/

typedef struct Beta {
	struct Alpha	*b	/* OPTIONAL */;
	struct Gamma	*g	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Beta_t;

/*** <<< FUNC-DECLS [Beta] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Beta;

/*** <<< POST-INCLUDE [Beta] >>> ***/

#include "Alpha.h"
#include "Gamma.h"

/*** <<< STAT-DEFS [Beta] >>> ***/

static asn_TYPE_member_t asn_MBR_Beta_1[] = {
	{ ATF_POINTER, 2, offsetof(struct Beta, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Alpha,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
	{ ATF_POINTER, 1, offsetof(struct Beta, g),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Gamma,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "g"
		},
};
static ber_tlv_tag_t asn_DEF_Beta_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Beta_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* b at 75 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* g at 76 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Beta_specs_1 = {
	sizeof(struct Beta),
	offsetof(struct Beta, _asn_ctx),
	asn_MAP_Beta_tag2el_1,
	2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Beta = {
	"Beta",
	"Beta",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Beta_tags_1,
	sizeof(asn_DEF_Beta_tags_1)
		/sizeof(asn_DEF_Beta_tags_1[0]), /* 1 */
	asn_DEF_Beta_tags_1,	/* Same as above */
	sizeof(asn_DEF_Beta_tags_1)
		/sizeof(asn_DEF_Beta_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Beta_1,
	2,	/* Elements count */
	&asn_SPC_Beta_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Gamma] >>> ***/

#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Gamma] >>> ***/

struct TwoThree;
struct Alpha;
struct Beta;

/*** <<< TYPE-DECLS [Gamma] >>> ***/

typedef struct Gamma {
	struct TwoThree	*o;
	struct Alpha	*a;
	struct Beta	*b;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Gamma_t;

/*** <<< FUNC-DECLS [Gamma] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Gamma;

/*** <<< POST-INCLUDE [Gamma] >>> ***/

#include "TwoThree.h"
#include "Alpha.h"
#include "Beta.h"

/*** <<< STAT-DEFS [Gamma] >>> ***/

static asn_TYPE_member_t asn_MBR_Gamma_1[] = {
	{ ATF_POINTER, 0, offsetof(struct Gamma, o),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TwoThree,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "o"
		},
	{ ATF_POINTER, 0, offsetof(struct Gamma, a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Alpha,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "a"
		},
	{ ATF_POINTER, 0, offsetof(struct Gamma, b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Beta,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "b"
		},
};
static ber_tlv_tag_t asn_DEF_Gamma_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_Gamma_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* o at 80 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* a at 81 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* b at 83 */
};
static asn_SEQUENCE_specifics_t asn_SPC_Gamma_specs_1 = {
	sizeof(struct Gamma),
	offsetof(struct Gamma, _asn_ctx),
	asn_MAP_Gamma_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* Start extensions */
	-1	/* Stop extensions */
};
asn_TYPE_descriptor_t asn_DEF_Gamma = {
	"Gamma",
	"Gamma",
	SEQUENCE_free,
	SEQUENCE_print,
	SEQUENCE_constraint,
	SEQUENCE_decode_ber,
	SEQUENCE_encode_der,
	SEQUENCE_decode_xer,
	SEQUENCE_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_Gamma_tags_1,
	sizeof(asn_DEF_Gamma_tags_1)
		/sizeof(asn_DEF_Gamma_tags_1[0]), /* 1 */
	asn_DEF_Gamma_tags_1,	/* Same as above */
	sizeof(asn_DEF_Gamma_tags_1)
		/sizeof(asn_DEF_Gamma_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_Gamma_1,
	3,	/* Elements count */
	&asn_SPC_Gamma_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [OneTwo] >>> ***/

#include <constr_SET.h>

/*** <<< DEPS [OneTwo] >>> ***/


/*
 * Method of determining the components presence
 */
typedef enum OneTwo_PR {
	OneTwo_PR_m12,	/* Member m12 is present */
} OneTwo_PR;

/*** <<< FWD-DECLS [OneTwo] >>> ***/

struct TwoThree;

/*** <<< TYPE-DECLS [OneTwo] >>> ***/

typedef struct OneTwo {
	struct TwoThree	*m12;
	
	/* Presence bitmask: ASN_SET_ISPRESENT(pOneTwo, OneTwo_PR_x) */
	unsigned int _presence_map
		[((1+(8*sizeof(unsigned int))-1)/(8*sizeof(unsigned int)))];
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} OneTwo_t;

/*** <<< FUNC-DECLS [OneTwo] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_OneTwo;

/*** <<< POST-INCLUDE [OneTwo] >>> ***/

#include "TwoThree.h"

/*** <<< STAT-DEFS [OneTwo] >>> ***/

static asn_TYPE_member_t asn_MBR_OneTwo_1[] = {
	{ ATF_POINTER, 0, offsetof(struct OneTwo, m12),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_TwoThree,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "m12"
		},
};
static ber_tlv_tag_t asn_DEF_OneTwo_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_OneTwo_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* m12 at 86 */
};
static uint8_t asn_MAP_OneTwo_mmap_1[(1 + (8 * sizeof(unsigned int)) - 1) / 8] = {
	(1 << 7)
};
static asn_SET_specifics_t asn_SPC_OneTwo_specs_1 = {
	sizeof(struct OneTwo),
	offsetof(struct OneTwo, _asn_ctx),
	offsetof(struct OneTwo, _presence_map),
	asn_MAP_OneTwo_tag2el_1,
	1,	/* Count of tags in the map */
	asn_MAP_OneTwo_tag2el_1,	/* Same as above */
	1,	/* Count of tags in the CXER map */
	0,	/* Whether extensible */
	(unsigned int *)asn_MAP_OneTwo_mmap_1	/* Mandatory elements map */
};
asn_TYPE_descriptor_t asn_DEF_OneTwo = {
	"OneTwo",
	"OneTwo",
	SET_free,
	SET_print,
	SET_constraint,
	SET_decode_ber,
	SET_encode_der,
	SET_decode_xer,
	SET_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_OneTwo_tags_1,
	sizeof(asn_DEF_OneTwo_tags_1)
		/sizeof(asn_DEF_OneTwo_tags_1[0]), /* 1 */
	asn_DEF_OneTwo_tags_1,	/* Same as above */
	sizeof(asn_DEF_OneTwo_tags_1)
		/sizeof(asn_DEF_OneTwo_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_OneTwo_1,
	1,	/* Elements count */
	&asn_SPC_OneTwo_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [TwoThree] >>> ***/

#include <constr_SET.h>

/*** <<< DEPS [TwoThree] >>> ***/


/*
 * Method of determining the components presence
 */
typedef enum TwoThree_PR {
	TwoThree_PR_m23,	/* Member m23 is present */
} TwoThree_PR;

/*** <<< FWD-DECLS [TwoThree] >>> ***/

struct ThreeOne;

/*** <<< TYPE-DECLS [TwoThree] >>> ***/

typedef struct TwoThree {
	struct ThreeOne	*m23;
	
	/* Presence bitmask: ASN_SET_ISPRESENT(pTwoThree, TwoThree_PR_x) */
	unsigned int _presence_map
		[((1+(8*sizeof(unsigned int))-1)/(8*sizeof(unsigned int)))];
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} TwoThree_t;

/*** <<< FUNC-DECLS [TwoThree] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_TwoThree;

/*** <<< POST-INCLUDE [TwoThree] >>> ***/

#include "ThreeOne.h"

/*** <<< STAT-DEFS [TwoThree] >>> ***/

static asn_TYPE_member_t asn_MBR_TwoThree_1[] = {
	{ ATF_POINTER, 0, offsetof(struct TwoThree, m23),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ThreeOne,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "m23"
		},
};
static ber_tlv_tag_t asn_DEF_TwoThree_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_TwoThree_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 } /* m23 at 87 */
};
static uint8_t asn_MAP_TwoThree_mmap_1[(1 + (8 * sizeof(unsigned int)) - 1) / 8] = {
	(1 << 7)
};
static asn_SET_specifics_t asn_SPC_TwoThree_specs_1 = {
	sizeof(struct TwoThree),
	offsetof(struct TwoThree, _asn_ctx),
	offsetof(struct TwoThree, _presence_map),
	asn_MAP_TwoThree_tag2el_1,
	1,	/* Count of tags in the map */
	asn_MAP_TwoThree_tag2el_1,	/* Same as above */
	1,	/* Count of tags in the CXER map */
	0,	/* Whether extensible */
	(unsigned int *)asn_MAP_TwoThree_mmap_1	/* Mandatory elements map */
};
asn_TYPE_descriptor_t asn_DEF_TwoThree = {
	"TwoThree",
	"TwoThree",
	SET_free,
	SET_print,
	SET_constraint,
	SET_decode_ber,
	SET_encode_der,
	SET_decode_xer,
	SET_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_TwoThree_tags_1,
	sizeof(asn_DEF_TwoThree_tags_1)
		/sizeof(asn_DEF_TwoThree_tags_1[0]), /* 1 */
	asn_DEF_TwoThree_tags_1,	/* Same as above */
	sizeof(asn_DEF_TwoThree_tags_1)
		/sizeof(asn_DEF_TwoThree_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_TwoThree_1,
	1,	/* Elements count */
	&asn_SPC_TwoThree_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ThreeOne] >>> ***/

#include <constr_SET.h>

/*** <<< DEPS [ThreeOne] >>> ***/


/*
 * Method of determining the components presence
 */
typedef enum ThreeOne_PR {
	ThreeOne_PR_m31,	/* Member m31 is present */
	ThreeOne_PR_g,	/* Member g is present */
} ThreeOne_PR;

/*** <<< FWD-DECLS [ThreeOne] >>> ***/

struct OneTwo;
struct Gamma;

/*** <<< TYPE-DECLS [ThreeOne] >>> ***/

typedef struct ThreeOne {
	struct OneTwo	*m31;
	struct Gamma	*g;
	
	/* Presence bitmask: ASN_SET_ISPRESENT(pThreeOne, ThreeOne_PR_x) */
	unsigned int _presence_map
		[((2+(8*sizeof(unsigned int))-1)/(8*sizeof(unsigned int)))];
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ThreeOne_t;

/*** <<< FUNC-DECLS [ThreeOne] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ThreeOne;

/*** <<< POST-INCLUDE [ThreeOne] >>> ***/

#include "OneTwo.h"
#include "Gamma.h"

/*** <<< STAT-DEFS [ThreeOne] >>> ***/

static asn_TYPE_member_t asn_MBR_ThreeOne_1[] = {
	{ ATF_POINTER, 0, offsetof(struct ThreeOne, m31),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OneTwo,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "m31"
		},
	{ ATF_POINTER, 0, offsetof(struct ThreeOne, g),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Gamma,
		.memb_constraints = 0,	/* Defer constraints checking to the member type */
		.per_constraints = 0,	/* PER is not compiled, use -gen-PER */
		.default_value = 0,
		.name = "g"
		},
};
static ber_tlv_tag_t asn_DEF_ThreeOne_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static asn_TYPE_tag2member_t asn_MAP_ThreeOne_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* m31 at 88 */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* g at 88 */
};
static uint8_t asn_MAP_ThreeOne_mmap_1[(2 + (8 * sizeof(unsigned int)) - 1) / 8] = {
	(1 << 7) | (1 << 6)
};
static asn_SET_specifics_t asn_SPC_ThreeOne_specs_1 = {
	sizeof(struct ThreeOne),
	offsetof(struct ThreeOne, _asn_ctx),
	offsetof(struct ThreeOne, _presence_map),
	asn_MAP_ThreeOne_tag2el_1,
	2,	/* Count of tags in the map */
	asn_MAP_ThreeOne_tag2el_1,	/* Same as above */
	2,	/* Count of tags in the CXER map */
	0,	/* Whether extensible */
	(unsigned int *)asn_MAP_ThreeOne_mmap_1	/* Mandatory elements map */
};
asn_TYPE_descriptor_t asn_DEF_ThreeOne = {
	"ThreeOne",
	"ThreeOne",
	SET_free,
	SET_print,
	SET_constraint,
	SET_decode_ber,
	SET_encode_der,
	SET_decode_xer,
	SET_encode_xer,
	0, 0,	/* No PER support, use "-gen-PER" to enable */
	0,	/* Use generic outmost tag fetcher */
	asn_DEF_ThreeOne_tags_1,
	sizeof(asn_DEF_ThreeOne_tags_1)
		/sizeof(asn_DEF_ThreeOne_tags_1[0]), /* 1 */
	asn_DEF_ThreeOne_tags_1,	/* Same as above */
	sizeof(asn_DEF_ThreeOne_tags_1)
		/sizeof(asn_DEF_ThreeOne_tags_1[0]), /* 1 */
	0,	/* No PER visible constraints */
	asn_MBR_ThreeOne_1,
	2,	/* Elements count */
	&asn_SPC_ThreeOne_specs_1	/* Additional specs */
};

