
/*** <<< INCLUDES [Int1] >>> ***/

#include <INTEGER.h>

/*** <<< TYPE-DECLS [Int1] >>> ***/

typedef INTEGER_t	 Int1_t;

/*** <<< FUNC-DECLS [Int1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int1;
asn_struct_free_f Int1_free;
asn_struct_print_f Int1_print;
asn_constr_check_f Int1_constraint;
ber_type_decoder_f Int1_decode_ber;
der_type_encoder_f Int1_encode_der;
xer_type_decoder_f Int1_decode_xer;
xer_type_encoder_f Int1_encode_xer;
#define Int1_ten	((Int1_t)10)

/*** <<< CODE [Int1] >>> ***/

/*
 * This type is implemented using INTEGER,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Int1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int1 = {
	"Int1",
	"Int1",
	&asn_OP_INTEGER,
	asn_DEF_Int1_tags_1,
	sizeof(asn_DEF_Int1_tags_1)
		/sizeof(asn_DEF_Int1_tags_1[0]), /* 1 */
	asn_DEF_Int1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int1_tags_1)
		/sizeof(asn_DEF_Int1_tags_1[0]), /* 1 */
	{ 0, 0, INTEGER_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int2] >>> ***/

#include "Int1.h"

/*** <<< TYPE-DECLS [Int2] >>> ***/

typedef Int1_t	 Int2_t;

/*** <<< FUNC-DECLS [Int2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int2;
asn_struct_free_f Int2_free;
asn_struct_print_f Int2_print;
asn_constr_check_f Int2_constraint;
ber_type_decoder_f Int2_decode_ber;
der_type_encoder_f Int2_encode_der;
xer_type_decoder_f Int2_decode_xer;
xer_type_encoder_f Int2_encode_xer;

/*** <<< CODE [Int2] >>> ***/

int
Int2_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int1_t *st = (const Int1_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	/* Check if the sign bit is present */
	value = st->buf ? ((st->buf[0] & 0x80) ? -1 : 1) : 0;
	
	if((value >= 0)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int1,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Int2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int2 = {
	"Int2",
	"Int2",
	&asn_OP_INTEGER,
	asn_DEF_Int2_tags_1,
	sizeof(asn_DEF_Int2_tags_1)
		/sizeof(asn_DEF_Int2_tags_1[0]), /* 1 */
	asn_DEF_Int2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int2_tags_1)
		/sizeof(asn_DEF_Int2_tags_1[0]), /* 1 */
	{ 0, 0, Int2_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int3] >>> ***/

#include "Int2.h"

/*** <<< TYPE-DECLS [Int3] >>> ***/

typedef Int2_t	 Int3_t;

/*** <<< FUNC-DECLS [Int3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int3;
asn_struct_free_f Int3_free;
asn_struct_print_f Int3_print;
asn_constr_check_f Int3_constraint;
ber_type_decoder_f Int3_decode_ber;
der_type_encoder_f Int3_encode_der;
xer_type_decoder_f Int3_decode_xer;
xer_type_encoder_f Int3_encode_xer;

/*** <<< CODE [Int3] >>> ***/

int
Int3_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int2_t *st = (const Int2_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value >= 0 && value <= 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int2,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Int3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int3 = {
	"Int3",
	"Int3",
	&asn_OP_INTEGER,
	asn_DEF_Int3_tags_1,
	sizeof(asn_DEF_Int3_tags_1)
		/sizeof(asn_DEF_Int3_tags_1[0]), /* 1 */
	asn_DEF_Int3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int3_tags_1)
		/sizeof(asn_DEF_Int3_tags_1[0]), /* 1 */
	{ 0, 0, Int3_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int4] >>> ***/

#include "Int3.h"

/*** <<< TYPE-DECLS [Int4] >>> ***/

typedef Int3_t	 Int4_t;

/*** <<< FUNC-DECLS [Int4] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int4;
asn_struct_free_f Int4_free;
asn_struct_print_f Int4_print;
asn_constr_check_f Int4_constraint;
ber_type_decoder_f Int4_decode_ber;
der_type_encoder_f Int4_encode_der;
xer_type_decoder_f Int4_decode_xer;
xer_type_encoder_f Int4_encode_xer;

/*** <<< CODE [Int4] >>> ***/

int
Int4_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int3_t *st = (const Int3_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value >= 1 && value <= 10)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int3,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Int4] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int4_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int4 = {
	"Int4",
	"Int4",
	&asn_OP_INTEGER,
	asn_DEF_Int4_tags_1,
	sizeof(asn_DEF_Int4_tags_1)
		/sizeof(asn_DEF_Int4_tags_1[0]), /* 1 */
	asn_DEF_Int4_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int4_tags_1)
		/sizeof(asn_DEF_Int4_tags_1[0]), /* 1 */
	{ 0, 0, Int4_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Int5] >>> ***/

#include "Int4.h"

/*** <<< TYPE-DECLS [Int5] >>> ***/

typedef Int4_t	 Int5_t;

/*** <<< FUNC-DECLS [Int5] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Int5;
asn_struct_free_f Int5_free;
asn_struct_print_f Int5_print;
asn_constr_check_f Int5_constraint;
ber_type_decoder_f Int5_decode_ber;
der_type_encoder_f Int5_encode_der;
xer_type_decoder_f Int5_decode_xer;
xer_type_encoder_f Int5_encode_xer;

/*** <<< CODE [Int5] >>> ***/

int
Int5_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int4_t *st = (const Int4_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value == 5)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Int4,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Int5] >>> ***/

static const ber_tlv_tag_t asn_DEF_Int5_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Int5 = {
	"Int5",
	"Int5",
	&asn_OP_INTEGER,
	asn_DEF_Int5_tags_1,
	sizeof(asn_DEF_Int5_tags_1)
		/sizeof(asn_DEF_Int5_tags_1[0]), /* 1 */
	asn_DEF_Int5_tags_1,	/* Same as above */
	sizeof(asn_DEF_Int5_tags_1)
		/sizeof(asn_DEF_Int5_tags_1[0]), /* 1 */
	{ 0, 0, Int5_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [ExtensibleExtensions] >>> ***/

#include <INTEGER.h>

/*** <<< TYPE-DECLS [ExtensibleExtensions] >>> ***/

typedef INTEGER_t	 ExtensibleExtensions_t;

/*** <<< FUNC-DECLS [ExtensibleExtensions] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ExtensibleExtensions;
asn_struct_free_f ExtensibleExtensions_free;
asn_struct_print_f ExtensibleExtensions_print;
asn_constr_check_f ExtensibleExtensions_constraint;
ber_type_decoder_f ExtensibleExtensions_decode_ber;
der_type_encoder_f ExtensibleExtensions_encode_der;
xer_type_decoder_f ExtensibleExtensions_decode_xer;
xer_type_encoder_f ExtensibleExtensions_encode_xer;

/*** <<< CODE [ExtensibleExtensions] >>> ***/

int
ExtensibleExtensions_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const INTEGER_t *st = (const INTEGER_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value >= 1 && value <= 255)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using INTEGER,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [ExtensibleExtensions] >>> ***/

static const ber_tlv_tag_t asn_DEF_ExtensibleExtensions_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (2 << 2))
};
asn_TYPE_descriptor_t asn_DEF_ExtensibleExtensions = {
	"ExtensibleExtensions",
	"ExtensibleExtensions",
	&asn_OP_INTEGER,
	asn_DEF_ExtensibleExtensions_tags_1,
	sizeof(asn_DEF_ExtensibleExtensions_tags_1)
		/sizeof(asn_DEF_ExtensibleExtensions_tags_1[0]), /* 1 */
	asn_DEF_ExtensibleExtensions_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExtensibleExtensions_tags_1)
		/sizeof(asn_DEF_ExtensibleExtensions_tags_1[0]), /* 1 */
	{ 0, 0, ExtensibleExtensions_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str1] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [Str1] >>> ***/

typedef IA5String_t	 Str1_t;

/*** <<< FUNC-DECLS [Str1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str1;
asn_struct_free_f Str1_free;
asn_struct_print_f Str1_print;
asn_constr_check_f Str1_constraint;
ber_type_decoder_f Str1_decode_ber;
der_type_encoder_f Str1_encode_der;
xer_type_decoder_f Str1_decode_xer;
xer_type_encoder_f Str1_encode_xer;

/*** <<< CODE [Str1] >>> ***/

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Str1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str1 = {
	"Str1",
	"Str1",
	&asn_OP_IA5String,
	asn_DEF_Str1_tags_1,
	sizeof(asn_DEF_Str1_tags_1)
		/sizeof(asn_DEF_Str1_tags_1[0]), /* 1 */
	asn_DEF_Str1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str1_tags_1)
		/sizeof(asn_DEF_Str1_tags_1[0]), /* 1 */
	{ 0, 0, IA5String_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str2] >>> ***/

#include "Str1.h"

/*** <<< TYPE-DECLS [Str2] >>> ***/

typedef Str1_t	 Str2_t;

/*** <<< FUNC-DECLS [Str2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str2;
asn_struct_free_f Str2_free;
asn_struct_print_f Str2_print;
asn_constr_check_f Str2_constraint;
ber_type_decoder_f Str2_decode_ber;
der_type_encoder_f Str2_encode_der;
xer_type_decoder_f Str2_decode_xer;
xer_type_encoder_f Str2_encode_xer;

/*** <<< CTABLES [Str2] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [Str2] >>> ***/

int
Str2_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Str1_t *st = (const Str1_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if(((size <= 20) || (size >= 25 && size <= 30))
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Str1,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Str2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str2 = {
	"Str2",
	"Str2",
	&asn_OP_IA5String,
	asn_DEF_Str2_tags_1,
	sizeof(asn_DEF_Str2_tags_1)
		/sizeof(asn_DEF_Str2_tags_1[0]), /* 1 */
	asn_DEF_Str2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str2_tags_1)
		/sizeof(asn_DEF_Str2_tags_1[0]), /* 1 */
	{ 0, 0, Str2_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str3] >>> ***/

#include "Str2.h"

/*** <<< TYPE-DECLS [Str3] >>> ***/

typedef Str2_t	 Str3_t;

/*** <<< FUNC-DECLS [Str3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str3;
asn_struct_free_f Str3_free;
asn_struct_print_f Str3_print;
asn_constr_check_f Str3_constraint;
ber_type_decoder_f Str3_decode_ber;
der_type_encoder_f Str3_encode_der;
xer_type_decoder_f Str3_decode_xer;
xer_type_encoder_f Str3_encode_xer;

/*** <<< CTABLES [Str3] >>> ***/

static const int permitted_alphabet_table_1[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  ABC             */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*     def          */
};

static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [Str3] >>> ***/

int
Str3_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Str2_t *st = (const Str2_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if(((size >= 10 && size <= 20) || (size >= 25 && size <= 27))
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Str2,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Str3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str3 = {
	"Str3",
	"Str3",
	&asn_OP_IA5String,
	asn_DEF_Str3_tags_1,
	sizeof(asn_DEF_Str3_tags_1)
		/sizeof(asn_DEF_Str3_tags_1[0]), /* 1 */
	asn_DEF_Str3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str3_tags_1)
		/sizeof(asn_DEF_Str3_tags_1[0]), /* 1 */
	{ 0, 0, Str3_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Str4] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [Str4] >>> ***/

typedef IA5String_t	 Str4_t;

/*** <<< FUNC-DECLS [Str4] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Str4;
asn_struct_free_f Str4_free;
asn_struct_print_f Str4_print;
asn_constr_check_f Str4_constraint;
ber_type_decoder_f Str4_decode_ber;
der_type_encoder_f Str4_encode_der;
xer_type_decoder_f Str4_decode_xer;
xer_type_encoder_f Str4_encode_xer;

/*** <<< CTABLES [Str4] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv <= 127)) return -1;
	}
	return 0;
}


/*** <<< CODE [Str4] >>> ***/

int
Str4_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Str4] >>> ***/

static const ber_tlv_tag_t asn_DEF_Str4_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Str4 = {
	"Str4",
	"Str4",
	&asn_OP_IA5String,
	asn_DEF_Str4_tags_1,
	sizeof(asn_DEF_Str4_tags_1)
		/sizeof(asn_DEF_Str4_tags_1[0]), /* 1 */
	asn_DEF_Str4_tags_1,	/* Same as above */
	sizeof(asn_DEF_Str4_tags_1)
		/sizeof(asn_DEF_Str4_tags_1[0]), /* 1 */
	{ 0, 0, Str4_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PER-Visible] >>> ***/

#include <IA5String.h>

/*** <<< TYPE-DECLS [PER-Visible] >>> ***/

typedef IA5String_t	 PER_Visible_t;

/*** <<< FUNC-DECLS [PER-Visible] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PER_Visible;
asn_struct_free_f PER_Visible_free;
asn_struct_print_f PER_Visible_print;
asn_constr_check_f PER_Visible_constraint;
ber_type_decoder_f PER_Visible_decode_ber;
der_type_encoder_f PER_Visible_encode_der;
xer_type_decoder_f PER_Visible_decode_xer;
xer_type_encoder_f PER_Visible_encode_xer;

/*** <<< CTABLES [PER-Visible] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [PER-Visible] >>> ***/

int
PER_Visible_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using IA5String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [PER-Visible] >>> ***/

static const ber_tlv_tag_t asn_DEF_PER_Visible_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PER_Visible = {
	"PER-Visible",
	"PER-Visible",
	&asn_OP_IA5String,
	asn_DEF_PER_Visible_tags_1,
	sizeof(asn_DEF_PER_Visible_tags_1)
		/sizeof(asn_DEF_PER_Visible_tags_1[0]), /* 1 */
	asn_DEF_PER_Visible_tags_1,	/* Same as above */
	sizeof(asn_DEF_PER_Visible_tags_1)
		/sizeof(asn_DEF_PER_Visible_tags_1[0]), /* 1 */
	{ 0, 0, PER_Visible_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [PER-Visible-2] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [PER-Visible-2] >>> ***/

typedef PER_Visible_t	 PER_Visible_2_t;

/*** <<< FUNC-DECLS [PER-Visible-2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PER_Visible_2;
asn_struct_free_f PER_Visible_2_free;
asn_struct_print_f PER_Visible_2_print;
asn_constr_check_f PER_Visible_2_constraint;
ber_type_decoder_f PER_Visible_2_decode_ber;
der_type_encoder_f PER_Visible_2_encode_der;
xer_type_decoder_f PER_Visible_2_decode_xer;
xer_type_encoder_f PER_Visible_2_encode_xer;

/*** <<< CTABLES [PER-Visible-2] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 69 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [PER-Visible-2] >>> ***/

int
PER_Visible_2_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [PER-Visible-2] >>> ***/

static const ber_tlv_tag_t asn_DEF_PER_Visible_2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_PER_Visible_2 = {
	"PER-Visible-2",
	"PER-Visible-2",
	&asn_OP_IA5String,
	asn_DEF_PER_Visible_2_tags_1,
	sizeof(asn_DEF_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_PER_Visible_2_tags_1[0]), /* 1 */
	asn_DEF_PER_Visible_2_tags_1,	/* Same as above */
	sizeof(asn_DEF_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_PER_Visible_2_tags_1[0]), /* 1 */
	{ 0, 0, PER_Visible_2_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Not-PER-Visible-1] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Not-PER-Visible-1] >>> ***/

typedef PER_Visible_t	 Not_PER_Visible_1_t;

/*** <<< FUNC-DECLS [Not-PER-Visible-1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_1;
asn_struct_free_f Not_PER_Visible_1_free;
asn_struct_print_f Not_PER_Visible_1_print;
asn_constr_check_f Not_PER_Visible_1_constraint;
ber_type_decoder_f Not_PER_Visible_1_decode_ber;
der_type_encoder_f Not_PER_Visible_1_encode_der;
xer_type_decoder_f Not_PER_Visible_1_decode_xer;
xer_type_encoder_f Not_PER_Visible_1_encode_xer;

/*** <<< CTABLES [Not-PER-Visible-1] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [Not-PER-Visible-1] >>> ***/

int
Not_PER_Visible_1_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Not-PER-Visible-1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Not_PER_Visible_1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_1 = {
	"Not-PER-Visible-1",
	"Not-PER-Visible-1",
	&asn_OP_IA5String,
	asn_DEF_Not_PER_Visible_1_tags_1,
	sizeof(asn_DEF_Not_PER_Visible_1_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_1_tags_1[0]), /* 1 */
	asn_DEF_Not_PER_Visible_1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Not_PER_Visible_1_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_1_tags_1[0]), /* 1 */
	{ 0, 0, Not_PER_Visible_1_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Not-PER-Visible-2] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Not-PER-Visible-2] >>> ***/

typedef PER_Visible_t	 Not_PER_Visible_2_t;

/*** <<< FUNC-DECLS [Not-PER-Visible-2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_2;
asn_struct_free_f Not_PER_Visible_2_free;
asn_struct_print_f Not_PER_Visible_2_print;
asn_constr_check_f Not_PER_Visible_2_constraint;
ber_type_decoder_f Not_PER_Visible_2_decode_ber;
der_type_encoder_f Not_PER_Visible_2_encode_der;
xer_type_decoder_f Not_PER_Visible_2_decode_xer;
xer_type_encoder_f Not_PER_Visible_2_encode_xer;

/*** <<< CTABLES [Not-PER-Visible-2] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 66)) return -1;
	}
	return 0;
}


/*** <<< CODE [Not-PER-Visible-2] >>> ***/

int
Not_PER_Visible_2_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Not-PER-Visible-2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Not_PER_Visible_2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_2 = {
	"Not-PER-Visible-2",
	"Not-PER-Visible-2",
	&asn_OP_IA5String,
	asn_DEF_Not_PER_Visible_2_tags_1,
	sizeof(asn_DEF_Not_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_2_tags_1[0]), /* 1 */
	asn_DEF_Not_PER_Visible_2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Not_PER_Visible_2_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_2_tags_1[0]), /* 1 */
	{ 0, 0, Not_PER_Visible_2_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Not-PER-Visible-3] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Not-PER-Visible-3] >>> ***/

typedef PER_Visible_t	 Not_PER_Visible_3_t;

/*** <<< FUNC-DECLS [Not-PER-Visible-3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_3;
asn_struct_free_f Not_PER_Visible_3_free;
asn_struct_print_f Not_PER_Visible_3_print;
asn_constr_check_f Not_PER_Visible_3_constraint;
ber_type_decoder_f Not_PER_Visible_3_decode_ber;
der_type_encoder_f Not_PER_Visible_3_encode_der;
xer_type_decoder_f Not_PER_Visible_3_decode_xer;
xer_type_encoder_f Not_PER_Visible_3_encode_xer;

/*** <<< CTABLES [Not-PER-Visible-3] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 66)) return -1;
	}
	return 0;
}


/*** <<< CODE [Not-PER-Visible-3] >>> ***/

int
Not_PER_Visible_3_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Not-PER-Visible-3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Not_PER_Visible_3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Not_PER_Visible_3 = {
	"Not-PER-Visible-3",
	"Not-PER-Visible-3",
	&asn_OP_IA5String,
	asn_DEF_Not_PER_Visible_3_tags_1,
	sizeof(asn_DEF_Not_PER_Visible_3_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_3_tags_1[0]), /* 1 */
	asn_DEF_Not_PER_Visible_3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Not_PER_Visible_3_tags_1)
		/sizeof(asn_DEF_Not_PER_Visible_3_tags_1[0]), /* 1 */
	{ 0, 0, Not_PER_Visible_3_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SIZE-but-not-FROM] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [SIZE-but-not-FROM] >>> ***/

typedef PER_Visible_t	 SIZE_but_not_FROM_t;

/*** <<< FUNC-DECLS [SIZE-but-not-FROM] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SIZE_but_not_FROM;
asn_struct_free_f SIZE_but_not_FROM_free;
asn_struct_print_f SIZE_but_not_FROM_print;
asn_constr_check_f SIZE_but_not_FROM_constraint;
ber_type_decoder_f SIZE_but_not_FROM_decode_ber;
der_type_encoder_f SIZE_but_not_FROM_encode_der;
xer_type_decoder_f SIZE_but_not_FROM_decode_xer;
xer_type_encoder_f SIZE_but_not_FROM_encode_xer;

/*** <<< CTABLES [SIZE-but-not-FROM] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 68)) return -1;
	}
	return 0;
}


/*** <<< CODE [SIZE-but-not-FROM] >>> ***/

int
SIZE_but_not_FROM_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 4)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [SIZE-but-not-FROM] >>> ***/

static const ber_tlv_tag_t asn_DEF_SIZE_but_not_FROM_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SIZE_but_not_FROM = {
	"SIZE-but-not-FROM",
	"SIZE-but-not-FROM",
	&asn_OP_IA5String,
	asn_DEF_SIZE_but_not_FROM_tags_1,
	sizeof(asn_DEF_SIZE_but_not_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_but_not_FROM_tags_1[0]), /* 1 */
	asn_DEF_SIZE_but_not_FROM_tags_1,	/* Same as above */
	sizeof(asn_DEF_SIZE_but_not_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_but_not_FROM_tags_1[0]), /* 1 */
	{ 0, 0, SIZE_but_not_FROM_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [SIZE-and-FROM] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [SIZE-and-FROM] >>> ***/

typedef PER_Visible_t	 SIZE_and_FROM_t;

/*** <<< FUNC-DECLS [SIZE-and-FROM] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SIZE_and_FROM;
asn_struct_free_f SIZE_and_FROM_free;
asn_struct_print_f SIZE_and_FROM_print;
asn_constr_check_f SIZE_and_FROM_constraint;
ber_type_decoder_f SIZE_and_FROM_decode_ber;
der_type_encoder_f SIZE_and_FROM_encode_der;
xer_type_decoder_f SIZE_and_FROM_decode_xer;
xer_type_encoder_f SIZE_and_FROM_encode_xer;

/*** <<< CTABLES [SIZE-and-FROM] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 68)) return -1;
	}
	return 0;
}


/*** <<< CODE [SIZE-and-FROM] >>> ***/

int
SIZE_and_FROM_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 4)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [SIZE-and-FROM] >>> ***/

static const ber_tlv_tag_t asn_DEF_SIZE_and_FROM_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_SIZE_and_FROM = {
	"SIZE-and-FROM",
	"SIZE-and-FROM",
	&asn_OP_IA5String,
	asn_DEF_SIZE_and_FROM_tags_1,
	sizeof(asn_DEF_SIZE_and_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_and_FROM_tags_1[0]), /* 1 */
	asn_DEF_SIZE_and_FROM_tags_1,	/* Same as above */
	sizeof(asn_DEF_SIZE_and_FROM_tags_1)
		/sizeof(asn_DEF_SIZE_and_FROM_tags_1[0]), /* 1 */
	{ 0, 0, SIZE_and_FROM_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Neither-SIZE-nor-FROM] >>> ***/

#include "PER-Visible.h"

/*** <<< TYPE-DECLS [Neither-SIZE-nor-FROM] >>> ***/

typedef PER_Visible_t	 Neither_SIZE_nor_FROM_t;

/*** <<< FUNC-DECLS [Neither-SIZE-nor-FROM] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Neither_SIZE_nor_FROM;
asn_struct_free_f Neither_SIZE_nor_FROM_free;
asn_struct_print_f Neither_SIZE_nor_FROM_print;
asn_constr_check_f Neither_SIZE_nor_FROM_constraint;
ber_type_decoder_f Neither_SIZE_nor_FROM_decode_ber;
der_type_encoder_f Neither_SIZE_nor_FROM_encode_der;
xer_type_decoder_f Neither_SIZE_nor_FROM_decode_xer;
xer_type_encoder_f Neither_SIZE_nor_FROM_encode_xer;

/*** <<< CTABLES [Neither-SIZE-nor-FROM] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 70)) return -1;
	}
	return 0;
}


/*** <<< CODE [Neither-SIZE-nor-FROM] >>> ***/

int
Neither_SIZE_nor_FROM_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PER_Visible_t *st = (const PER_Visible_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using PER_Visible,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Neither-SIZE-nor-FROM] >>> ***/

static const ber_tlv_tag_t asn_DEF_Neither_SIZE_nor_FROM_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (22 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Neither_SIZE_nor_FROM = {
	"Neither-SIZE-nor-FROM",
	"Neither-SIZE-nor-FROM",
	&asn_OP_IA5String,
	asn_DEF_Neither_SIZE_nor_FROM_tags_1,
	sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1)
		/sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1[0]), /* 1 */
	asn_DEF_Neither_SIZE_nor_FROM_tags_1,	/* Same as above */
	sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1)
		/sizeof(asn_DEF_Neither_SIZE_nor_FROM_tags_1[0]), /* 1 */
	{ 0, 0, Neither_SIZE_nor_FROM_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-4] >>> ***/

#include <UTF8String.h>

/*** <<< TYPE-DECLS [Utf8-4] >>> ***/

typedef UTF8String_t	 Utf8_4_t;

/*** <<< FUNC-DECLS [Utf8-4] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_4;
asn_struct_free_f Utf8_4_free;
asn_struct_print_f Utf8_4_print;
asn_constr_check_f Utf8_4_constraint;
ber_type_decoder_f Utf8_4_decode_ber;
der_type_encoder_f Utf8_4_encode_der;
xer_type_decoder_f Utf8_4_decode_xer;
xer_type_encoder_f Utf8_4_encode_xer;

/*** <<< CTABLES [Utf8-4] >>> ***/

static int check_permitted_alphabet_1(const void *sptr) {
	if(UTF8String_length((const UTF8String_t *)sptr) < 0)
		return -1; /* Alphabet (sic!) test failed. */
	
	return 0;
}


/*** <<< CODE [Utf8-4] >>> ***/

int
Utf8_4_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using UTF8String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Utf8-4] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_4_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_4 = {
	"Utf8-4",
	"Utf8-4",
	&asn_OP_UTF8String,
	asn_DEF_Utf8_4_tags_1,
	sizeof(asn_DEF_Utf8_4_tags_1)
		/sizeof(asn_DEF_Utf8_4_tags_1[0]), /* 1 */
	asn_DEF_Utf8_4_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_4_tags_1)
		/sizeof(asn_DEF_Utf8_4_tags_1[0]), /* 1 */
	{ 0, 0, Utf8_4_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-3] >>> ***/

#include "Utf8-2.h"

/*** <<< TYPE-DECLS [Utf8-3] >>> ***/

typedef Utf8_2_t	 Utf8_3_t;

/*** <<< FUNC-DECLS [Utf8-3] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_3;
asn_struct_free_f Utf8_3_free;
asn_struct_print_f Utf8_3_print;
asn_constr_check_f Utf8_3_constraint;
ber_type_decoder_f Utf8_3_decode_ber;
der_type_encoder_f Utf8_3_encode_der;
xer_type_decoder_f Utf8_3_decode_xer;
xer_type_encoder_f Utf8_3_encode_xer;

/*** <<< CTABLES [Utf8-3] >>> ***/

static const int permitted_alphabet_table_1[128] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,	/*  ABCDEFGHIJKLMNO */
16,17,18,19,20,21,22,23,24,25,26, 0, 0, 0, 0, 0,	/* PQRSTUVWXYZ      */
 0,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,	/*  abcdefghijklmno */
42,43,44,45,46,47,48,49,50,51,52, 0, 0, 0, 0, 0,	/* pqrstuvwxyz      */
};

static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is UTF8String */
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(cv >= 0x80) return -1;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [Utf8-3] >>> ***/

int
Utf8_3_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Utf8_2_t *st = (const Utf8_2_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = UTF8String_length(st);
	if((ssize_t)size < 0) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: UTF-8: broken encoding (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((size >= 1 && size <= 2)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Utf8_2,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Utf8-3] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_3_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_3 = {
	"Utf8-3",
	"Utf8-3",
	&asn_OP_UTF8String,
	asn_DEF_Utf8_3_tags_1,
	sizeof(asn_DEF_Utf8_3_tags_1)
		/sizeof(asn_DEF_Utf8_3_tags_1[0]), /* 1 */
	asn_DEF_Utf8_3_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_3_tags_1)
		/sizeof(asn_DEF_Utf8_3_tags_1[0]), /* 1 */
	{ 0, 0, Utf8_3_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-2] >>> ***/

#include "Utf8-1.h"

/*** <<< TYPE-DECLS [Utf8-2] >>> ***/

typedef Utf8_1_t	 Utf8_2_t;

/*** <<< FUNC-DECLS [Utf8-2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_2;
asn_struct_free_f Utf8_2_free;
asn_struct_print_f Utf8_2_print;
asn_constr_check_f Utf8_2_constraint;
ber_type_decoder_f Utf8_2_decode_ber;
der_type_encoder_f Utf8_2_encode_der;
xer_type_decoder_f Utf8_2_decode_xer;
xer_type_encoder_f Utf8_2_encode_xer;

/*** <<< CODE [Utf8-2] >>> ***/

int
Utf8_2_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Utf8_1_t *st = (const Utf8_1_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = UTF8String_length(st);
	if((ssize_t)size < 0) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: UTF-8: broken encoding (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((size >= 1 && size <= 2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Utf8_1,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Utf8-2] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_2 = {
	"Utf8-2",
	"Utf8-2",
	&asn_OP_UTF8String,
	asn_DEF_Utf8_2_tags_1,
	sizeof(asn_DEF_Utf8_2_tags_1)
		/sizeof(asn_DEF_Utf8_2_tags_1[0]), /* 1 */
	asn_DEF_Utf8_2_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_2_tags_1)
		/sizeof(asn_DEF_Utf8_2_tags_1[0]), /* 1 */
	{ 0, 0, Utf8_2_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Utf8-1] >>> ***/

#include <UTF8String.h>

/*** <<< TYPE-DECLS [Utf8-1] >>> ***/

typedef UTF8String_t	 Utf8_1_t;

/*** <<< FUNC-DECLS [Utf8-1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Utf8_1;
asn_struct_free_f Utf8_1_free;
asn_struct_print_f Utf8_1_print;
asn_constr_check_f Utf8_1_constraint;
ber_type_decoder_f Utf8_1_decode_ber;
der_type_encoder_f Utf8_1_encode_der;
xer_type_decoder_f Utf8_1_decode_xer;
xer_type_encoder_f Utf8_1_encode_xer;

/*** <<< CODE [Utf8-1] >>> ***/

/*
 * This type is implemented using UTF8String,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Utf8-1] >>> ***/

static const ber_tlv_tag_t asn_DEF_Utf8_1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (12 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Utf8_1 = {
	"Utf8-1",
	"Utf8-1",
	&asn_OP_UTF8String,
	asn_DEF_Utf8_1_tags_1,
	sizeof(asn_DEF_Utf8_1_tags_1)
		/sizeof(asn_DEF_Utf8_1_tags_1[0]), /* 1 */
	asn_DEF_Utf8_1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Utf8_1_tags_1)
		/sizeof(asn_DEF_Utf8_1_tags_1[0]), /* 1 */
	{ 0, 0, UTF8String_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [VisibleIdentifier] >>> ***/

#include "Identifier.h"

/*** <<< TYPE-DECLS [VisibleIdentifier] >>> ***/

typedef Identifier_t	 VisibleIdentifier_t;

/*** <<< FUNC-DECLS [VisibleIdentifier] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_VisibleIdentifier;
asn_struct_free_f VisibleIdentifier_free;
asn_struct_print_f VisibleIdentifier_print;
asn_constr_check_f VisibleIdentifier_constraint;
ber_type_decoder_f VisibleIdentifier_decode_ber;
der_type_encoder_f VisibleIdentifier_encode_der;
xer_type_decoder_f VisibleIdentifier_decode_xer;
xer_type_encoder_f VisibleIdentifier_encode_xer;

/*** <<< CTABLES [VisibleIdentifier] >>> ***/

static const int permitted_alphabet_table_1[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*     $            */
 2, 3, 4, 5, 6, 7, 8, 9,10,11, 0, 0, 0, 0, 0, 0,	/* 0123456789       */
 0,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,	/*  ABCDEFGHIJKLMNO */
27,28,29,30,31,32,33,34,35,36,37, 0, 0, 0, 0,38,	/* PQRSTUVWXYZ    _ */
 0,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,	/*  abcdefghijklmno */
54,55,56,57,58,59,60,61,62,63,64, 0, 0, 0, 0, 0,	/* pqrstuvwxyz      */
};

static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [VisibleIdentifier] >>> ***/

int
VisibleIdentifier_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Identifier_t *st = (const Identifier_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 32)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using Identifier,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [VisibleIdentifier] >>> ***/

static const ber_tlv_tag_t asn_DEF_VisibleIdentifier_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (26 << 2))
};
asn_TYPE_descriptor_t asn_DEF_VisibleIdentifier = {
	"VisibleIdentifier",
	"VisibleIdentifier",
	&asn_OP_VisibleString,
	asn_DEF_VisibleIdentifier_tags_1,
	sizeof(asn_DEF_VisibleIdentifier_tags_1)
		/sizeof(asn_DEF_VisibleIdentifier_tags_1[0]), /* 1 */
	asn_DEF_VisibleIdentifier_tags_1,	/* Same as above */
	sizeof(asn_DEF_VisibleIdentifier_tags_1)
		/sizeof(asn_DEF_VisibleIdentifier_tags_1[0]), /* 1 */
	{ 0, 0, VisibleIdentifier_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< INCLUDES [Sequence] >>> ***/

#include "Int1.h"
#include "Int4.h"
#include <BOOLEAN.h>
#include <ENUMERATED.h>
#include <NULL.h>
#include "Int5.h"
#include <constr_SEQUENCE.h>

/*** <<< DEPS [Sequence] >>> ***/

typedef enum enum_c {
	enum_c_one	= 1,
	enum_c_two	= 2,
	/*
	 * Enumeration is extensible
	 */
	enum_c_three	= 3
} e_enum_c;

/*** <<< TYPE-DECLS [Sequence] >>> ***/

typedef struct Sequence {
	Int1_t	*int1_c;	/* DEFAULT 3 */
	Int4_t	 int4;
	Int4_t	 int4_c;
	BOOLEAN_t	*Bool;	/* DEFAULT 1 */
	ENUMERATED_t	 enum_c;
	NULL_t	*null;	/* OPTIONAL */
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	Int5_t	*int5_c;	/* OPTIONAL */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Sequence_t;

/*** <<< FUNC-DECLS [Sequence] >>> ***/

/* extern asn_TYPE_descriptor_t asn_DEF_enum_c_6;	// (Use -fall-defs-global to expose) */
extern asn_TYPE_descriptor_t asn_DEF_Sequence;
extern asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1;
extern asn_TYPE_member_t asn_MBR_Sequence_1[7];

/*** <<< CODE [Sequence] >>> ***/

/*
 * This type is implemented using ENUMERATED,
 * so here we adjust the DEF accordingly.
 */
static int
memb_int1_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int1_t *st = (const Int1_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value >= -2)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_int4_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int4_t *st = (const Int4_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value >= 5 && value <= 7)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_int5_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const Int5_t *st = (const Int5_t *)sptr;
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if(asn_INTEGER2long(st, &value)) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value too large (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((value == 5)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}


/*** <<< STAT-DEFS [Sequence] >>> ***/

static int asn_DFL_2_cmp_3(const void *sptr) {
	const Int1_t *st = sptr;
	
	if(!st) {
		return -1; /* No value is not a default value */
	}
	
	/* Test default value 3 */
	long value;
	if(asn_INTEGER2long(st, &value))
		return -1;
	return (value != 3);
}
static int asn_DFL_2_set_3(void **sptr) {
	Int1_t *st = *sptr;
	
	if(!st) {
		st = (*sptr = CALLOC(1, sizeof(*st)));
		if(!st) return -1;
	}
	
	/* Install default value 3 */
	return asn_long2INTEGER(st, 3);
}
static int asn_DFL_5_cmp_1(const void *sptr) {
	const BOOLEAN_t *st = sptr;
	
	if(!st) {
		return -1; /* No value is not a default value */
	}
	
	/* Test default value 1 */
	return (*st != 1);
}
static int asn_DFL_5_set_1(void **sptr) {
	BOOLEAN_t *st = *sptr;
	
	if(!st) {
		st = (*sptr = CALLOC(1, sizeof(*st)));
		if(!st) return -1;
	}
	
	/* Install default value 1 */
	*st = 1;
	return 0;
}
static const asn_INTEGER_enum_map_t asn_MAP_enum_c_value2enum_6[] = {
	{ 1,	3,	"one" },
	{ 2,	3,	"two" },
	{ 3,	5,	"three" }
	/* This list is extensible */
};
static const unsigned int asn_MAP_enum_c_enum2value_6[] = {
	0,	/* one(1) */
	2,	/* three(3) */
	1	/* two(2) */
	/* This list is extensible */
};
static const asn_INTEGER_specifics_t asn_SPC_enum_c_specs_6 = {
	asn_MAP_enum_c_value2enum_6,	/* "tag" => N; sorted by tag */
	asn_MAP_enum_c_enum2value_6,	/* N => "tag"; sorted by N */
	3,	/* Number of elements in the maps */
	3,	/* Extensions before this member */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_enum_c_tags_6[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_enum_c_6 = {
	"enum-c",
	"enum-c",
	&asn_OP_ENUMERATED,
	asn_DEF_enum_c_tags_6,
	sizeof(asn_DEF_enum_c_tags_6)
		/sizeof(asn_DEF_enum_c_tags_6[0]), /* 1 */
	asn_DEF_enum_c_tags_6,	/* Same as above */
	sizeof(asn_DEF_enum_c_tags_6)
		/sizeof(asn_DEF_enum_c_tags_6[0]), /* 1 */
	{ 0, 0, ENUMERATED_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_enum_c_specs_6	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_Sequence_1[] = {
	{ ATF_POINTER, 1, offsetof(struct Sequence, int1_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Int1,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints =  memb_int1_c_constraint_1 },
		.default_value_cmp = &asn_DFL_2_cmp_3,	/* Compare DEFAULT 3 */
		.default_value_set = &asn_DFL_2_set_3,	/* Set DEFAULT 3 */
		.name = "int1-c"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, int4),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = +1,	/* EXPLICIT tag at current level */
		.type = &asn_DEF_Int4,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "int4"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, int4_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Int4,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints =  memb_int4_c_constraint_1 },
		0, 0, /* No default value */
		.name = "int4-c"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, Bool),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (1 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_BOOLEAN,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		.default_value_cmp = &asn_DFL_5_cmp_1,	/* Compare DEFAULT 1 */
		.default_value_set = &asn_DFL_5_set_1,	/* Set DEFAULT 1 */
		.name = "bool"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, enum_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_enum_c_6,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "enum-c"
		},
	{ ATF_POINTER, 2, offsetof(struct Sequence, null),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_NULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "null"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, int5_c),
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Int5,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints =  memb_int5_c_constraint_1 },
		0, 0, /* No default value */
		.name = "int5-c"
		},
};
static const ber_tlv_tag_t asn_DEF_Sequence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_Sequence_tag2el_1[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (1 << 2)), 3, 0, 0 }, /* bool */
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 2 }, /* int1-c */
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 2, -1, 1 }, /* int4-c */
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 6, -2, 0 }, /* int5-c */
    { (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)), 5, 0, 0 }, /* null */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 4, 0, 0 }, /* enum-c */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 1, 0, 0 } /* int4 */
};
asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1 = {
	sizeof(struct Sequence),
	offsetof(struct Sequence, _asn_ctx),
	.tag2el = asn_MAP_Sequence_tag2el_1,
	.tag2el_count = 7,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	6,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_Sequence = {
	"Sequence",
	"Sequence",
	&asn_OP_SEQUENCE,
	asn_DEF_Sequence_tags_1,
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	asn_DEF_Sequence_tags_1,	/* Same as above */
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_Sequence_1,
	7,	/* Elements count */
	&asn_SPC_Sequence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SequenceOf] >>> ***/

#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< FWD-DECLS [SequenceOf] >>> ***/

struct Sequence;

/*** <<< TYPE-DECLS [SequenceOf] >>> ***/

typedef struct SequenceOf {
	A_SEQUENCE_OF(struct Sequence) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SequenceOf_t;

/*** <<< FUNC-DECLS [SequenceOf] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SequenceOf;

/*** <<< POST-INCLUDE [SequenceOf] >>> ***/

#include "Sequence.h"

/*** <<< STAT-DEFS [SequenceOf] >>> ***/

static asn_TYPE_member_t asn_MBR_SequenceOf_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Sequence,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_SequenceOf_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_SequenceOf_specs_1 = {
	sizeof(struct SequenceOf),
	offsetof(struct SequenceOf, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_SequenceOf = {
	"SequenceOf",
	"SequenceOf",
	&asn_OP_SEQUENCE_OF,
	asn_DEF_SequenceOf_tags_1,
	sizeof(asn_DEF_SequenceOf_tags_1)
		/sizeof(asn_DEF_SequenceOf_tags_1[0]), /* 1 */
	asn_DEF_SequenceOf_tags_1,	/* Same as above */
	sizeof(asn_DEF_SequenceOf_tags_1)
		/sizeof(asn_DEF_SequenceOf_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_OF_constraint },
	asn_MBR_SequenceOf_1,
	1,	/* Single element */
	&asn_SPC_SequenceOf_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Enum0] >>> ***/

#include <ENUMERATED.h>

/*** <<< DEPS [Enum0] >>> ***/

typedef enum Enum0 {
	Enum0_one	= 0,
	Enum0_two	= 1
} e_Enum0;

/*** <<< TYPE-DECLS [Enum0] >>> ***/

typedef ENUMERATED_t	 Enum0_t;

/*** <<< FUNC-DECLS [Enum0] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Enum0;
asn_struct_free_f Enum0_free;
asn_struct_print_f Enum0_print;
asn_constr_check_f Enum0_constraint;
ber_type_decoder_f Enum0_decode_ber;
der_type_encoder_f Enum0_encode_der;
xer_type_decoder_f Enum0_decode_xer;
xer_type_encoder_f Enum0_encode_xer;

/*** <<< CODE [Enum0] >>> ***/

/*
 * This type is implemented using ENUMERATED,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Enum0] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_Enum0_value2enum_1[] = {
	{ 0,	3,	"one" },
	{ 1,	3,	"two" }
};
static const unsigned int asn_MAP_Enum0_enum2value_1[] = {
	0,	/* one(0) */
	1	/* two(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_Enum0_specs_1 = {
	asn_MAP_Enum0_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Enum0_enum2value_1,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_Enum0_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Enum0 = {
	"Enum0",
	"Enum0",
	&asn_OP_ENUMERATED,
	asn_DEF_Enum0_tags_1,
	sizeof(asn_DEF_Enum0_tags_1)
		/sizeof(asn_DEF_Enum0_tags_1[0]), /* 1 */
	asn_DEF_Enum0_tags_1,	/* Same as above */
	sizeof(asn_DEF_Enum0_tags_1)
		/sizeof(asn_DEF_Enum0_tags_1[0]), /* 1 */
	{ 0, 0, ENUMERATED_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Enum0_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Enum1] >>> ***/

#include <NativeEnumerated.h>

/*** <<< DEPS [Enum1] >>> ***/

typedef enum Enum1 {
	Enum1_one	= 0,
	Enum1_two	= 1
} e_Enum1;

/*** <<< TYPE-DECLS [Enum1] >>> ***/

typedef long	 Enum1_t;

/*** <<< FUNC-DECLS [Enum1] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Enum1;
asn_struct_free_f Enum1_free;
asn_struct_print_f Enum1_print;
asn_constr_check_f Enum1_constraint;
ber_type_decoder_f Enum1_decode_ber;
der_type_encoder_f Enum1_encode_der;
xer_type_decoder_f Enum1_decode_xer;
xer_type_encoder_f Enum1_encode_xer;

/*** <<< CODE [Enum1] >>> ***/

int
Enum1_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value == 0)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using NativeEnumerated,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Enum1] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_Enum1_value2enum_1[] = {
	{ 0,	3,	"one" },
	{ 1,	3,	"two" }
};
static const unsigned int asn_MAP_Enum1_enum2value_1[] = {
	0,	/* one(0) */
	1	/* two(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_Enum1_specs_1 = {
	asn_MAP_Enum1_value2enum_1,	/* "tag" => N; sorted by tag */
	asn_MAP_Enum1_enum2value_1,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_Enum1_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Enum1 = {
	"Enum1",
	"Enum1",
	&asn_OP_NativeEnumerated,
	asn_DEF_Enum1_tags_1,
	sizeof(asn_DEF_Enum1_tags_1)
		/sizeof(asn_DEF_Enum1_tags_1[0]), /* 1 */
	asn_DEF_Enum1_tags_1,	/* Same as above */
	sizeof(asn_DEF_Enum1_tags_1)
		/sizeof(asn_DEF_Enum1_tags_1[0]), /* 1 */
	{ 0, 0, Enum1_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Enum1_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Identifier] >>> ***/

#include <VisibleString.h>

/*** <<< TYPE-DECLS [Identifier] >>> ***/

typedef VisibleString_t	 Identifier_t;

/*** <<< FUNC-DECLS [Identifier] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Identifier;
asn_struct_free_f Identifier_free;
asn_struct_print_f Identifier_print;
asn_constr_check_f Identifier_constraint;
ber_type_decoder_f Identifier_decode_ber;
der_type_encoder_f Identifier_encode_der;
xer_type_decoder_f Identifier_decode_xer;
xer_type_encoder_f Identifier_encode_xer;

/*** <<< CTABLES [Identifier] >>> ***/

static const int permitted_alphabet_table_1[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*     $            */
 2, 3, 4, 5, 6, 7, 8, 9,10,11, 0, 0, 0, 0, 0, 0,	/* 0123456789       */
 0,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,	/*  ABCDEFGHIJKLMNO */
27,28,29,30,31,32,33,34,35,36,37, 0, 0, 0, 0,38,	/* PQRSTUVWXYZ    _ */
 0,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,	/*  abcdefghijklmno */
54,55,56,57,58,59,60,61,62,63,64, 0, 0, 0, 0, 0,	/* pqrstuvwxyz      */
};

static int check_permitted_alphabet_1(const void *sptr) {
	const int *table = permitted_alphabet_table_1;
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [Identifier] >>> ***/

int
Identifier_constraint(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size;
	
	if((size >= 1 && size <= 32)
		 && !check_permitted_alphabet_1(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

/*
 * This type is implemented using VisibleString,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [Identifier] >>> ***/

static const ber_tlv_tag_t asn_DEF_Identifier_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (26 << 2))
};
asn_TYPE_descriptor_t asn_DEF_Identifier = {
	"Identifier",
	"Identifier",
	&asn_OP_VisibleString,
	asn_DEF_Identifier_tags_1,
	sizeof(asn_DEF_Identifier_tags_1)
		/sizeof(asn_DEF_Identifier_tags_1[0]), /* 1 */
	asn_DEF_Identifier_tags_1,	/* Same as above */
	sizeof(asn_DEF_Identifier_tags_1)
		/sizeof(asn_DEF_Identifier_tags_1[0]), /* 1 */
	{ 0, 0, Identifier_constraint },
	0, 0,	/* No members */
	0	/* No specifics */
};


/*** <<< asn_constant.h >>> ***/

/*
 * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
 */

#ifndef _ASN_CONSTANT_H
#define _ASN_CONSTANT_H

#ifdef __cplusplus
extern "C" {
#endif

#define maxIdentifier (32)


#ifdef __cplusplus
}
#endif

#endif /* _ASN_CONSTANT_H */
