
/*** <<< INCLUDES [PDU] >>> ***/

#include <IA5String.h>
#include <VisibleString.h>
#include <PrintableString.h>
#include <NumericString.h>
#include <UTF8String.h>
#include <BMPString.h>
#include <UniversalString.h>
#include <NativeReal.h>
#include <OBJECT_IDENTIFIER.h>
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [PDU] >>> ***/

struct PDU;

/*** <<< TYPE-DECLS [PDU] >>> ***/

typedef struct PDU {
	struct many {
		A_SEQUENCE_OF(struct PDU) list;
		
		/* Context for parsing across buffer boundaries */
		asn_struct_ctx_t _asn_ctx;
	} *many;
	IA5String_t	*ia5	/* OPTIONAL */;
	IA5String_t	*ia5_c	/* OPTIONAL */;
	IA5String_t	*ia5_ce	/* OPTIONAL */;
	IA5String_t	*ia5_ir	/* OPTIONAL */;
	VisibleString_t	*vs	/* OPTIONAL */;
	VisibleString_t	*vs_c	/* OPTIONAL */;
	VisibleString_t	*vs_ce	/* OPTIONAL */;
	VisibleString_t	*vs_ir	/* OPTIONAL */;
	PrintableString_t	*pr	/* OPTIONAL */;
	PrintableString_t	*pr_c	/* OPTIONAL */;
	PrintableString_t	*pr_ir	/* OPTIONAL */;
	NumericString_t	*ns	/* OPTIONAL */;
	NumericString_t	*ns_c	/* OPTIONAL */;
	NumericString_t	*ns_ce	/* OPTIONAL */;
	NumericString_t	*ns_ir	/* OPTIONAL */;
	UTF8String_t	*ut_c	/* OPTIONAL */;
	UTF8String_t	*ut_ce	/* OPTIONAL */;
	UTF8String_t	*ut_ir	/* OPTIONAL */;
	BMPString_t	*bm	/* OPTIONAL */;
	BMPString_t	*bm_c	/* OPTIONAL */;
	BMPString_t	*bm_cs	/* OPTIONAL */;
	BMPString_t	*bm_ce	/* OPTIONAL */;
	BMPString_t	*bm_ir	/* OPTIONAL */;
	UniversalString_t	*us	/* OPTIONAL */;
	UniversalString_t	*us_c	/* OPTIONAL */;
	UniversalString_t	*us_cs	/* OPTIONAL */;
	UniversalString_t	*us_ce	/* OPTIONAL */;
	UniversalString_t	*us_ir	/* OPTIONAL */;
	double	*real	/* OPTIONAL */;
	OBJECT_IDENTIFIER_t	*oid	/* OPTIONAL */;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} PDU_t;

/*** <<< FUNC-DECLS [PDU] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PDU;
extern asn_SEQUENCE_specifics_t asn_SPC_PDU_specs_1;
extern asn_TYPE_member_t asn_MBR_PDU_1[31];

/*** <<< POST-INCLUDE [PDU] >>> ***/

#include "PDU.h"

/*** <<< CTABLES [PDU] >>> ***/

static int check_permitted_alphabet_5(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_6(const void *sptr) {
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_7[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  AB              */
 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0, 0, 0, 0, 0,	/*         XYZ      */
};
static const int permitted_alphabet_code2value_7[5] = {
65,66,88,89,90,};


static int check_permitted_alphabet_7(const void *sptr) {
	const int *table = permitted_alphabet_table_7;
	/* The underlying type is IA5String */
	const IA5String_t *st = (const IA5String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_9(const void *sptr) {
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_10(const void *sptr) {
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_11[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  AB              */
 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0, 0, 0, 0, 0,	/*         XYZ      */
};
static const int permitted_alphabet_code2value_11[5] = {
65,66,88,89,90,};


static int check_permitted_alphabet_11(const void *sptr) {
	const int *table = permitted_alphabet_table_11;
	/* The underlying type is VisibleString */
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_13(const void *sptr) {
	/* The underlying type is PrintableString */
	const PrintableString_t *st = (const PrintableString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_14[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  AB              */
 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0, 0, 0, 0, 0,	/*         XYZ      */
};
static const int permitted_alphabet_code2value_14[5] = {
65,66,88,89,90,};


static int check_permitted_alphabet_14(const void *sptr) {
	const int *table = permitted_alphabet_table_14;
	/* The underlying type is PrintableString */
	const PrintableString_t *st = (const PrintableString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_16(const void *sptr) {
	/* The underlying type is NumericString */
	const NumericString_t *st = (const NumericString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 53 && cv <= 57)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_17(const void *sptr) {
	/* The underlying type is NumericString */
	const NumericString_t *st = (const NumericString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!(cv >= 53 && cv <= 57)) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_18[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,	/*  1       9       */
};
static const int permitted_alphabet_code2value_18[2] = {
49,57,};


static int check_permitted_alphabet_18(const void *sptr) {
	const int *table = permitted_alphabet_table_18;
	/* The underlying type is NumericString */
	const NumericString_t *st = (const NumericString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(!table[cv]) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_21[128] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  A               */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,	/*           Z      */
};

static int check_permitted_alphabet_21(const void *sptr) {
	const int *table = permitted_alphabet_table_21;
	/* The underlying type is UTF8String */
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	for(; ch < end; ch++) {
		uint8_t cv = *ch;
		if(cv >= 0x80) return -1;
		if(!table[cv]) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_23(const void *sptr) {
	/* The underlying type is BMPString */
	const BMPString_t *st = (const BMPString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 2) return -1; /* (size%2)! */
	for(; ch < end; ch += 2) {
		uint16_t cv = (ch[0] << 8)
				| ch[1];
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_24(const void *sptr) {
	/* The underlying type is BMPString */
	const BMPString_t *st = (const BMPString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 2) return -1; /* (size%2)! */
	for(; ch < end; ch += 2) {
		uint16_t cv = (ch[0] << 8)
				| ch[1];
		if(!(cv <= 65533)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_25(const void *sptr) {
	/* The underlying type is BMPString */
	const BMPString_t *st = (const BMPString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 2) return -1; /* (size%2)! */
	for(; ch < end; ch += 2) {
		uint16_t cv = (ch[0] << 8)
				| ch[1];
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_26[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  AB              */
 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0, 0, 0, 0, 0,	/*         XYZ      */
};
static const int permitted_alphabet_code2value_26[5] = {
65,66,88,89,90,};


static int check_permitted_alphabet_26(const void *sptr) {
	const int *table = permitted_alphabet_table_26;
	/* The underlying type is BMPString */
	const BMPString_t *st = (const BMPString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 2) return -1; /* (size%2)! */
	for(; ch < end; ch += 2) {
		uint16_t cv = (ch[0] << 8)
				| ch[1];
		if(cv > 255) return -1;
		if(!table[cv]) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_28(const void *sptr) {
	/* The underlying type is UniversalString */
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 4) return -1; /* (size%4)! */
	for(; ch < end; ch += 4) {
		uint32_t cv = (ch[0] << 24)
				| (ch[1] << 16)
				| (ch[2] << 8)
				|  ch[3];
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static int check_permitted_alphabet_29(const void *sptr) {
	/* The underlying type is UniversalString */
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 4) return -1; /* (size%4)! */
	for(; ch < end; ch += 4) {
		uint32_t cv = (ch[0] << 24)
				| (ch[1] << 16)
				| (ch[2] << 8)
				|  ch[3];
		(void)cv; /* Unused variable */
	}
	return 0;
}

static int check_permitted_alphabet_30(const void *sptr) {
	/* The underlying type is UniversalString */
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 4) return -1; /* (size%4)! */
	for(; ch < end; ch += 4) {
		uint32_t cv = (ch[0] << 24)
				| (ch[1] << 16)
				| (ch[2] << 8)
				|  ch[3];
		if(!(cv >= 65 && cv <= 90)) return -1;
	}
	return 0;
}

static const int permitted_alphabet_table_31[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*                  */
 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/*  AB              */
 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 5, 0, 0, 0, 0, 0,	/*         XYZ      */
};
static const int permitted_alphabet_code2value_31[5] = {
65,66,88,89,90,};


static int check_permitted_alphabet_31(const void *sptr) {
	const int *table = permitted_alphabet_table_31;
	/* The underlying type is UniversalString */
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	const uint8_t *ch = st->buf;
	const uint8_t *end = ch + st->size;
	
	if(st->size % 4) return -1; /* (size%4)! */
	for(; ch < end; ch += 4) {
		uint32_t cv = (ch[0] << 24)
				| (ch[1] << 16)
				| (ch[2] << 8)
				|  ch[3];
		if(cv > 255) return -1;
		if(!table[cv]) return -1;
	}
	return 0;
}


/*** <<< CODE [PDU] >>> ***/

static int
memb_ia5_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_5(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_ia5_ce_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_6(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_ia5_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const IA5String_t *st = (const IA5String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_7(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_ia5_ir_7_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_7)/sizeof(permitted_alphabet_table_7[0]))
		return -1;
	return permitted_alphabet_table_7[value] - 1;
}
static int asn_PER_MAP_ia5_ir_7_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_7)/sizeof(permitted_alphabet_code2value_7[0]))
		return -1;
	return permitted_alphabet_code2value_7[code];
}
static int
memb_vs_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_9(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_vs_ce_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_10(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_vs_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const VisibleString_t *st = (const VisibleString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_11(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_vs_ir_11_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_11)/sizeof(permitted_alphabet_table_11[0]))
		return -1;
	return permitted_alphabet_table_11[value] - 1;
}
static int asn_PER_MAP_vs_ir_11_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_11)/sizeof(permitted_alphabet_code2value_11[0]))
		return -1;
	return permitted_alphabet_code2value_11[code];
}
static int
memb_pr_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PrintableString_t *st = (const PrintableString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_13(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_pr_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const PrintableString_t *st = (const PrintableString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_14(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_pr_ir_14_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_14)/sizeof(permitted_alphabet_table_14[0]))
		return -1;
	return permitted_alphabet_table_14[value] - 1;
}
static int asn_PER_MAP_pr_ir_14_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_14)/sizeof(permitted_alphabet_code2value_14[0]))
		return -1;
	return permitted_alphabet_code2value_14[code];
}
static int
memb_ns_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const NumericString_t *st = (const NumericString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_16(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_ns_ce_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const NumericString_t *st = (const NumericString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_17(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_ns_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const NumericString_t *st = (const NumericString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_18(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_ns_ir_18_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_18)/sizeof(permitted_alphabet_table_18[0]))
		return -1;
	return permitted_alphabet_table_18[value] - 1;
}
static int asn_PER_MAP_ns_ir_18_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_18)/sizeof(permitted_alphabet_code2value_18[0]))
		return -1;
	return permitted_alphabet_code2value_18[code];
}
static int
memb_ut_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = UTF8String_length(st);
	if((ssize_t)size < 0) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: UTF-8: broken encoding (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((size == 6)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_ut_ce_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = UTF8String_length(st);
	if((ssize_t)size < 0) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: UTF-8: broken encoding (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	if((size == 6)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_ut_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UTF8String_t *st = (const UTF8String_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_21(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_bm_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BMPString_t *st = (const BMPString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_23(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_bm_cs_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BMPString_t *st = (const BMPString_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size >> 1;	/* 2 byte per character */
	
	if((size == 6)
		 && !check_permitted_alphabet_24(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_bm_ce_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BMPString_t *st = (const BMPString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_25(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_bm_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const BMPString_t *st = (const BMPString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_26(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_bm_ir_26_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_26)/sizeof(permitted_alphabet_table_26[0]))
		return -1;
	return permitted_alphabet_table_26[value] - 1;
}
static int asn_PER_MAP_bm_ir_26_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_26)/sizeof(permitted_alphabet_code2value_26[0]))
		return -1;
	return permitted_alphabet_code2value_26[code];
}
static int
memb_us_c_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_28(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_us_cs_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	size_t size;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	size = st->size >> 2;	/* 4 byte per character */
	
	if((size == 6)
		 && !check_permitted_alphabet_29(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_us_ce_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_30(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_us_ir_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	const UniversalString_t *st = (const UniversalString_t *)sptr;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(!check_permitted_alphabet_31(st)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int asn_PER_MAP_us_ir_31_v2c(unsigned int value) {
	if(value >= sizeof(permitted_alphabet_table_31)/sizeof(permitted_alphabet_table_31[0]))
		return -1;
	return permitted_alphabet_table_31[value] - 1;
}
static int asn_PER_MAP_us_ir_31_c2v(unsigned int code) {
	if(code >= sizeof(permitted_alphabet_code2value_31)/sizeof(permitted_alphabet_code2value_31[0]))
		return -1;
	return permitted_alphabet_code2value_31[code];
}

/*** <<< CTDEFS [PDU] >>> ***/

static asn_per_constraints_t asn_PER_memb_ia5_c_constr_5 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_ia5_ce_constr_6 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_ia5_ir_constr_7 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	asn_PER_MAP_ia5_ir_7_v2c,	/* Value to PER code map */
	asn_PER_MAP_ia5_ir_7_c2v	/* PER code to value map */
};
static asn_per_constraints_t asn_PER_memb_vs_c_constr_9 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_vs_ce_constr_10 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_vs_ir_constr_11 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	asn_PER_MAP_vs_ir_11_v2c,	/* Value to PER code map */
	asn_PER_MAP_vs_ir_11_c2v	/* PER code to value map */
};
static asn_per_constraints_t asn_PER_memb_pr_c_constr_13 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_pr_ir_constr_14 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	asn_PER_MAP_pr_ir_14_v2c,	/* Value to PER code map */
	asn_PER_MAP_pr_ir_14_c2v	/* PER code to value map */
};
static asn_per_constraints_t asn_PER_memb_ns_c_constr_16 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  53,  57 }	/* (53..57) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_ns_ce_constr_17 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_ns_ir_constr_18 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 1,  1,  49,  57 }	/* (49..57) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	asn_PER_MAP_ns_ir_18_v2c,	/* Value to PER code map */
	asn_PER_MAP_ns_ir_18_c2v	/* PER code to value map */
};
static asn_per_constraints_t asn_PER_memb_ut_c_constr_19 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_ut_ce_constr_20 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_ut_ir_constr_21 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_bm_c_constr_23 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_bm_cs_constr_24 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65533 }	/* (0..65533) */,
	{ APC_CONSTRAINED,	 0,  0,  6,  6 }	/* (SIZE(6..6)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_bm_ce_constr_25 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_bm_ir_constr_26 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	asn_PER_MAP_bm_ir_26_v2c,	/* Value to PER code map */
	asn_PER_MAP_bm_ir_26_c2v	/* PER code to value map */
};
static asn_per_constraints_t asn_PER_memb_us_c_constr_28 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 5,  5,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_us_cs_constr_29 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 32,  32,  0,  2147483647 }	/* (0..4294967295) */,
	{ APC_CONSTRAINED,	 0,  0,  6,  6 }	/* (SIZE(6..6)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_us_ce_constr_30 CC_NOTUSED = {
	{ APC_CONSTRAINED,	32, 32, 0, 2147483647 } /* special case 1 */
	,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	0, 0	/* No PER character map necessary */
};
static asn_per_constraints_t asn_PER_memb_us_ir_constr_31 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 3,  3,  65,  90 }	/* (65..90) */,
	{ APC_SEMI_CONSTRAINED,	-1, -1,  0,  0 }	/* (SIZE(0..MAX)) */,
	asn_PER_MAP_us_ir_31_v2c,	/* Value to PER code map */
	asn_PER_MAP_us_ir_31_c2v	/* PER code to value map */
};

/*** <<< STAT-DEFS [PDU] >>> ***/

static asn_TYPE_member_t asn_MBR_many_2[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_PDU,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_many_tags_2[] = {
	(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static asn_SET_OF_specifics_t asn_SPC_many_specs_2 = {
	sizeof(struct many),
	offsetof(struct many, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_many_2 = {
	"many",
	"many",
	&asn_OP_SEQUENCE_OF,
	asn_DEF_many_tags_2,
	sizeof(asn_DEF_many_tags_2)
		/sizeof(asn_DEF_many_tags_2[0]) - 1, /* 1 */
	asn_DEF_many_tags_2,	/* Same as above */
	sizeof(asn_DEF_many_tags_2)
		/sizeof(asn_DEF_many_tags_2[0]), /* 2 */
	{ 0, 0, SEQUENCE_OF_constraint },
	asn_MBR_many_2,
	1,	/* Single element */
	&asn_SPC_many_specs_2	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_PDU_1[] = {
	{ ATF_POINTER, 31, offsetof(struct PDU, many),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_many_2,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "many"
		},
	{ ATF_POINTER, 30, offsetof(struct PDU, ia5),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "ia5"
		},
	{ ATF_POINTER, 29, offsetof(struct PDU, ia5_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ia5_c_constr_5, .general_constraints =  memb_ia5_c_constraint_1 },
		0, 0, /* No default value */
		.name = "ia5-c"
		},
	{ ATF_POINTER, 28, offsetof(struct PDU, ia5_ce),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ia5_ce_constr_6, .general_constraints =  memb_ia5_ce_constraint_1 },
		0, 0, /* No default value */
		.name = "ia5-ce"
		},
	{ ATF_POINTER, 27, offsetof(struct PDU, ia5_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_IA5String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ia5_ir_constr_7, .general_constraints =  memb_ia5_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "ia5-ir"
		},
	{ ATF_POINTER, 26, offsetof(struct PDU, vs),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VisibleString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "vs"
		},
	{ ATF_POINTER, 25, offsetof(struct PDU, vs_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VisibleString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_vs_c_constr_9, .general_constraints =  memb_vs_c_constraint_1 },
		0, 0, /* No default value */
		.name = "vs-c"
		},
	{ ATF_POINTER, 24, offsetof(struct PDU, vs_ce),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VisibleString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_vs_ce_constr_10, .general_constraints =  memb_vs_ce_constraint_1 },
		0, 0, /* No default value */
		.name = "vs-ce"
		},
	{ ATF_POINTER, 23, offsetof(struct PDU, vs_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_VisibleString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_vs_ir_constr_11, .general_constraints =  memb_vs_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "vs-ir"
		},
	{ ATF_POINTER, 22, offsetof(struct PDU, pr),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PrintableString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "pr"
		},
	{ ATF_POINTER, 21, offsetof(struct PDU, pr_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PrintableString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_pr_c_constr_13, .general_constraints =  memb_pr_c_constraint_1 },
		0, 0, /* No default value */
		.name = "pr-c"
		},
	{ ATF_POINTER, 20, offsetof(struct PDU, pr_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_PrintableString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_pr_ir_constr_14, .general_constraints =  memb_pr_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "pr-ir"
		},
	{ ATF_POINTER, 19, offsetof(struct PDU, ns),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NumericString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "ns"
		},
	{ ATF_POINTER, 18, offsetof(struct PDU, ns_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NumericString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ns_c_constr_16, .general_constraints =  memb_ns_c_constraint_1 },
		0, 0, /* No default value */
		.name = "ns-c"
		},
	{ ATF_POINTER, 17, offsetof(struct PDU, ns_ce),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NumericString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ns_ce_constr_17, .general_constraints =  memb_ns_ce_constraint_1 },
		0, 0, /* No default value */
		.name = "ns-ce"
		},
	{ ATF_POINTER, 16, offsetof(struct PDU, ns_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (15 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NumericString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ns_ir_constr_18, .general_constraints =  memb_ns_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "ns-ir"
		},
	{ ATF_POINTER, 15, offsetof(struct PDU, ut_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (16 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ut_c_constr_19, .general_constraints =  memb_ut_c_constraint_1 },
		0, 0, /* No default value */
		.name = "ut-c"
		},
	{ ATF_POINTER, 14, offsetof(struct PDU, ut_ce),
		.tag = (ASN_TAG_CLASS_CONTEXT | (17 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ut_ce_constr_20, .general_constraints =  memb_ut_ce_constraint_1 },
		0, 0, /* No default value */
		.name = "ut-ce"
		},
	{ ATF_POINTER, 13, offsetof(struct PDU, ut_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (18 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_ut_ir_constr_21, .general_constraints =  memb_ut_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "ut-ir"
		},
	{ ATF_POINTER, 12, offsetof(struct PDU, bm),
		.tag = (ASN_TAG_CLASS_CONTEXT | (19 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BMPString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "bm"
		},
	{ ATF_POINTER, 11, offsetof(struct PDU, bm_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (20 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BMPString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_bm_c_constr_23, .general_constraints =  memb_bm_c_constraint_1 },
		0, 0, /* No default value */
		.name = "bm-c"
		},
	{ ATF_POINTER, 10, offsetof(struct PDU, bm_cs),
		.tag = (ASN_TAG_CLASS_CONTEXT | (21 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BMPString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_bm_cs_constr_24, .general_constraints =  memb_bm_cs_constraint_1 },
		0, 0, /* No default value */
		.name = "bm-cs"
		},
	{ ATF_POINTER, 9, offsetof(struct PDU, bm_ce),
		.tag = (ASN_TAG_CLASS_CONTEXT | (22 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BMPString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_bm_ce_constr_25, .general_constraints =  memb_bm_ce_constraint_1 },
		0, 0, /* No default value */
		.name = "bm-ce"
		},
	{ ATF_POINTER, 8, offsetof(struct PDU, bm_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (23 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BMPString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_bm_ir_constr_26, .general_constraints =  memb_bm_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "bm-ir"
		},
	{ ATF_POINTER, 7, offsetof(struct PDU, us),
		.tag = (ASN_TAG_CLASS_CONTEXT | (24 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniversalString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "us"
		},
	{ ATF_POINTER, 6, offsetof(struct PDU, us_c),
		.tag = (ASN_TAG_CLASS_CONTEXT | (25 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniversalString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_us_c_constr_28, .general_constraints =  memb_us_c_constraint_1 },
		0, 0, /* No default value */
		.name = "us-c"
		},
	{ ATF_POINTER, 5, offsetof(struct PDU, us_cs),
		.tag = (ASN_TAG_CLASS_CONTEXT | (26 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniversalString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_us_cs_constr_29, .general_constraints =  memb_us_cs_constraint_1 },
		0, 0, /* No default value */
		.name = "us-cs"
		},
	{ ATF_POINTER, 4, offsetof(struct PDU, us_ce),
		.tag = (ASN_TAG_CLASS_CONTEXT | (27 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniversalString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_us_ce_constr_30, .general_constraints =  memb_us_ce_constraint_1 },
		0, 0, /* No default value */
		.name = "us-ce"
		},
	{ ATF_POINTER, 3, offsetof(struct PDU, us_ir),
		.tag = (ASN_TAG_CLASS_CONTEXT | (28 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UniversalString,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = &asn_PER_memb_us_ir_constr_31, .general_constraints =  memb_us_ir_constraint_1 },
		0, 0, /* No default value */
		.name = "us-ir"
		},
	{ ATF_POINTER, 2, offsetof(struct PDU, real),
		.tag = (ASN_TAG_CLASS_CONTEXT | (29 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NativeReal,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "real"
		},
	{ ATF_POINTER, 1, offsetof(struct PDU, oid),
		.tag = (ASN_TAG_CLASS_CONTEXT | (30 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OBJECT_IDENTIFIER,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "oid"
		},
};
static const int asn_MAP_PDU_oms_1[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 };
static const ber_tlv_tag_t asn_DEF_PDU_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_PDU_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* many */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* ia5 */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* ia5-c */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* ia5-ce */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* ia5-ir */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* vs */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* vs-c */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* vs-ce */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* vs-ir */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* pr */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* pr-c */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* pr-ir */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* ns */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* ns-c */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 }, /* ns-ce */
    { (ASN_TAG_CLASS_CONTEXT | (15 << 2)), 15, 0, 0 }, /* ns-ir */
    { (ASN_TAG_CLASS_CONTEXT | (16 << 2)), 16, 0, 0 }, /* ut-c */
    { (ASN_TAG_CLASS_CONTEXT | (17 << 2)), 17, 0, 0 }, /* ut-ce */
    { (ASN_TAG_CLASS_CONTEXT | (18 << 2)), 18, 0, 0 }, /* ut-ir */
    { (ASN_TAG_CLASS_CONTEXT | (19 << 2)), 19, 0, 0 }, /* bm */
    { (ASN_TAG_CLASS_CONTEXT | (20 << 2)), 20, 0, 0 }, /* bm-c */
    { (ASN_TAG_CLASS_CONTEXT | (21 << 2)), 21, 0, 0 }, /* bm-cs */
    { (ASN_TAG_CLASS_CONTEXT | (22 << 2)), 22, 0, 0 }, /* bm-ce */
    { (ASN_TAG_CLASS_CONTEXT | (23 << 2)), 23, 0, 0 }, /* bm-ir */
    { (ASN_TAG_CLASS_CONTEXT | (24 << 2)), 24, 0, 0 }, /* us */
    { (ASN_TAG_CLASS_CONTEXT | (25 << 2)), 25, 0, 0 }, /* us-c */
    { (ASN_TAG_CLASS_CONTEXT | (26 << 2)), 26, 0, 0 }, /* us-cs */
    { (ASN_TAG_CLASS_CONTEXT | (27 << 2)), 27, 0, 0 }, /* us-ce */
    { (ASN_TAG_CLASS_CONTEXT | (28 << 2)), 28, 0, 0 }, /* us-ir */
    { (ASN_TAG_CLASS_CONTEXT | (29 << 2)), 29, 0, 0 }, /* real */
    { (ASN_TAG_CLASS_CONTEXT | (30 << 2)), 30, 0, 0 } /* oid */
};
asn_SEQUENCE_specifics_t asn_SPC_PDU_specs_1 = {
	sizeof(struct PDU),
	offsetof(struct PDU, _asn_ctx),
	.tag2el = asn_MAP_PDU_tag2el_1,
	.tag2el_count = 31,	/* Count of tags in the map */
	asn_MAP_PDU_oms_1,	/* Optional members */
	31, 0,	/* Root/Additions */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PDU = {
	"PDU",
	"PDU",
	&asn_OP_SEQUENCE,
	asn_DEF_PDU_tags_1,
	sizeof(asn_DEF_PDU_tags_1)
		/sizeof(asn_DEF_PDU_tags_1[0]), /* 1 */
	asn_DEF_PDU_tags_1,	/* Same as above */
	sizeof(asn_DEF_PDU_tags_1)
		/sizeof(asn_DEF_PDU_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_PDU_1,
	31,	/* Elements count */
	&asn_SPC_PDU_specs_1	/* Additional specs */
};

