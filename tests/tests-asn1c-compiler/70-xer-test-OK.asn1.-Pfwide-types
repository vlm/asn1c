
/*** <<< INCLUDES [PDU] >>> ***/

#include "Sequence.h"
#include "Set.h"
#include "SequenceOf.h"
#include "ExtensibleSet.h"
#include "ExtensibleSequence.h"
#include "ExtensibleSequence2.h"
#include "SetOfNULL.h"
#include "SetOfREAL.h"
#include "SetOfEnums.h"
#include "NamedSetOfNULL.h"
#include "NamedSetOfREAL.h"
#include "NamedSetOfEnums.h"
#include "SeqOfZuka.h"
#include "SetOfChoice.h"
#include "NamedSetOfChoice.h"
#include <constr_CHOICE.h>

/*** <<< DEPS [PDU] >>> ***/

typedef enum PDU_PR {
	PDU_PR_NOTHING,	/* No components present */
	PDU_PR_sequence,
	PDU_PR_set,
	PDU_PR_sequenceOf,
	PDU_PR_extensibleSet,
	PDU_PR_extensibleSequence,
	PDU_PR_extensibleSequence2,
	PDU_PR_setOfNULL,
	PDU_PR_setOfREAL,
	PDU_PR_setOfEnums,
	PDU_PR_namedSetOfNULL,
	PDU_PR_namedSetOfREAL,
	PDU_PR_namedSetOfEnums,
	PDU_PR_seqOfZuka,
	PDU_PR_setOfChoice,
	PDU_PR_namedSetOfChoice
	/* Extensions may appear below */
	
} PDU_PR;

/*** <<< TYPE-DECLS [PDU] >>> ***/

typedef struct PDU {
	PDU_PR present;
	union PDU_u {
		Sequence_t	 sequence;
		Set_t	 set;
		SequenceOf_t	 sequenceOf;
		ExtensibleSet_t	 extensibleSet;
		ExtensibleSequence_t	 extensibleSequence;
		ExtensibleSequence2_t	 extensibleSequence2;
		SetOfNULL_t	 setOfNULL;
		SetOfREAL_t	 setOfREAL;
		SetOfEnums_t	 setOfEnums;
		NamedSetOfNULL_t	 namedSetOfNULL;
		NamedSetOfREAL_t	 namedSetOfREAL;
		NamedSetOfEnums_t	 namedSetOfEnums;
		SeqOfZuka_t	 seqOfZuka;
		SetOfChoice_t	 setOfChoice;
		NamedSetOfChoice_t	 namedSetOfChoice;
		/*
		 * This type is extensible,
		 * possible extensions are below.
		 */
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} PDU_t;

/*** <<< FUNC-DECLS [PDU] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_PDU;

/*** <<< STAT-DEFS [PDU] >>> ***/

static asn_TYPE_member_t asn_MBR_PDU_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.sequence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Sequence,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "sequence"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.set),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Set,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "set"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.sequenceOf),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SequenceOf,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "sequenceOf"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.extensibleSet),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExtensibleSet,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "extensibleSet"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.extensibleSequence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (4 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExtensibleSequence,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "extensibleSequence"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.extensibleSequence2),
		.tag = (ASN_TAG_CLASS_CONTEXT | (5 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_ExtensibleSequence2,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "extensibleSequence2"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.setOfNULL),
		.tag = (ASN_TAG_CLASS_CONTEXT | (6 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SetOfNULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "setOfNULL"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.setOfREAL),
		.tag = (ASN_TAG_CLASS_CONTEXT | (7 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SetOfREAL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "setOfREAL"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.setOfEnums),
		.tag = (ASN_TAG_CLASS_CONTEXT | (8 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SetOfEnums,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "setOfEnums"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.namedSetOfNULL),
		.tag = (ASN_TAG_CLASS_CONTEXT | (9 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NamedSetOfNULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "namedSetOfNULL"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.namedSetOfREAL),
		.tag = (ASN_TAG_CLASS_CONTEXT | (10 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NamedSetOfREAL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "namedSetOfREAL"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.namedSetOfEnums),
		.tag = (ASN_TAG_CLASS_CONTEXT | (11 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NamedSetOfEnums,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "namedSetOfEnums"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.seqOfZuka),
		.tag = (ASN_TAG_CLASS_CONTEXT | (12 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SeqOfZuka,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "seqOfZuka"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.setOfChoice),
		.tag = (ASN_TAG_CLASS_CONTEXT | (13 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_SetOfChoice,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "setOfChoice"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct PDU, choice.namedSetOfChoice),
		.tag = (ASN_TAG_CLASS_CONTEXT | (14 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NamedSetOfChoice,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "namedSetOfChoice"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_PDU_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* sequence */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* set */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* sequenceOf */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 }, /* extensibleSet */
    { (ASN_TAG_CLASS_CONTEXT | (4 << 2)), 4, 0, 0 }, /* extensibleSequence */
    { (ASN_TAG_CLASS_CONTEXT | (5 << 2)), 5, 0, 0 }, /* extensibleSequence2 */
    { (ASN_TAG_CLASS_CONTEXT | (6 << 2)), 6, 0, 0 }, /* setOfNULL */
    { (ASN_TAG_CLASS_CONTEXT | (7 << 2)), 7, 0, 0 }, /* setOfREAL */
    { (ASN_TAG_CLASS_CONTEXT | (8 << 2)), 8, 0, 0 }, /* setOfEnums */
    { (ASN_TAG_CLASS_CONTEXT | (9 << 2)), 9, 0, 0 }, /* namedSetOfNULL */
    { (ASN_TAG_CLASS_CONTEXT | (10 << 2)), 10, 0, 0 }, /* namedSetOfREAL */
    { (ASN_TAG_CLASS_CONTEXT | (11 << 2)), 11, 0, 0 }, /* namedSetOfEnums */
    { (ASN_TAG_CLASS_CONTEXT | (12 << 2)), 12, 0, 0 }, /* seqOfZuka */
    { (ASN_TAG_CLASS_CONTEXT | (13 << 2)), 13, 0, 0 }, /* setOfChoice */
    { (ASN_TAG_CLASS_CONTEXT | (14 << 2)), 14, 0, 0 } /* namedSetOfChoice */
};
static asn_CHOICE_specifics_t asn_SPC_PDU_specs_1 = {
	sizeof(struct PDU),
	offsetof(struct PDU, _asn_ctx),
	offsetof(struct PDU, present),
	sizeof(((struct PDU *)0)->present),
	.tag2el = asn_MAP_PDU_tag2el_1,
	.tag2el_count = 15,	/* Count of tags in the map */
	0, 0,
	.first_extension = 15	/* Extensions start */
};
asn_TYPE_descriptor_t asn_DEF_PDU = {
	"PDU",
	"PDU",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, CHOICE_constraint },
	asn_MBR_PDU_1,
	15,	/* Elements count */
	&asn_SPC_PDU_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Sequence] >>> ***/

#include <INTEGER.h>
#include <BIT_STRING.h>
#include <UTF8String.h>
#include <constr_SEQUENCE.h>

/*** <<< FWD-DECLS [Sequence] >>> ***/

struct Sequence;

/*** <<< TYPE-DECLS [Sequence] >>> ***/

typedef struct Sequence {
	INTEGER_t	 integer;
	struct Sequence	*sequence;	/* OPTIONAL */
	BIT_STRING_t	*bits;	/* OPTIONAL */
	UTF8String_t	 string;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Sequence_t;

/*** <<< FUNC-DECLS [Sequence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Sequence;
extern asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1;
extern asn_TYPE_member_t asn_MBR_Sequence_1[4];

/*** <<< POST-INCLUDE [Sequence] >>> ***/

#include "Sequence.h"

/*** <<< STAT-DEFS [Sequence] >>> ***/

asn_TYPE_member_t asn_MBR_Sequence_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, integer),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "integer"
		},
	{ ATF_POINTER, 2, offsetof(struct Sequence, sequence),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_Sequence,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "sequence"
		},
	{ ATF_POINTER, 1, offsetof(struct Sequence, bits),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_BIT_STRING,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "bits"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Sequence, string),
		.tag = (ASN_TAG_CLASS_CONTEXT | (3 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "string"
		},
};
static const ber_tlv_tag_t asn_DEF_Sequence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_Sequence_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* integer */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* sequence */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 }, /* bits */
    { (ASN_TAG_CLASS_CONTEXT | (3 << 2)), 3, 0, 0 } /* string */
};
asn_SEQUENCE_specifics_t asn_SPC_Sequence_specs_1 = {
	sizeof(struct Sequence),
	offsetof(struct Sequence, _asn_ctx),
	.tag2el = asn_MAP_Sequence_tag2el_1,
	.tag2el_count = 4,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_Sequence = {
	"Sequence",
	"Sequence",
	&asn_OP_SEQUENCE,
	asn_DEF_Sequence_tags_1,
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	asn_DEF_Sequence_tags_1,	/* Same as above */
	sizeof(asn_DEF_Sequence_tags_1)
		/sizeof(asn_DEF_Sequence_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_Sequence_1,
	4,	/* Elements count */
	&asn_SPC_Sequence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [Set] >>> ***/

#include <RELATIVE-OID.h>
#include <OCTET_STRING.h>
#include <constr_SET.h>

/*** <<< DEPS [Set] >>> ***/


/*
 * Method of determining the components presence
 */
typedef enum Set_PR {
	Set_PR_roid,	/* Member roid is present */
	Set_PR_opaque,	/* Member opaque is present */
} Set_PR;

/*** <<< TYPE-DECLS [Set] >>> ***/

typedef struct Set {
	RELATIVE_OID_t	 roid;
	OCTET_STRING_t	*opaque;	/* OPTIONAL */
	
	/* Presence bitmask: ASN_SET_ISPRESENT(pSet, Set_PR_x) */
	unsigned int _presence_map
		[((2+(8*sizeof(unsigned int))-1)/(8*sizeof(unsigned int)))];
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} Set_t;

/*** <<< FUNC-DECLS [Set] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_Set;
extern asn_SET_specifics_t asn_SPC_Set_specs_1;
extern asn_TYPE_member_t asn_MBR_Set_1[2];

/*** <<< STAT-DEFS [Set] >>> ***/

asn_TYPE_member_t asn_MBR_Set_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Set, roid),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_RELATIVE_OID,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "roid"
		},
	{ ATF_POINTER, 1, offsetof(struct Set, opaque),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_OCTET_STRING,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "opaque"
		},
};
static const ber_tlv_tag_t asn_DEF_Set_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_Set_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* roid */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* opaque */
};
static const uint8_t asn_MAP_Set_mmap_1[(2 + (8 * sizeof(unsigned int)) - 1) / 8] = {
	(1 << 7) | (0 << 6)
};
asn_SET_specifics_t asn_SPC_Set_specs_1 = {
	sizeof(struct Set),
	offsetof(struct Set, _asn_ctx),
	offsetof(struct Set, _presence_map),
	.tag2el = asn_MAP_Set_tag2el_1,
	.tag2el_count = 2,	/* Count of tags in the map */
	asn_MAP_Set_tag2el_1,	/* Same as above */
	2,	/* Count of tags in the CXER map */
	0,	/* Whether extensible */
	(const unsigned int *)asn_MAP_Set_mmap_1	/* Mandatory elements map */
};
asn_TYPE_descriptor_t asn_DEF_Set = {
	"Set",
	"Set",
	&asn_OP_SET,
	asn_DEF_Set_tags_1,
	sizeof(asn_DEF_Set_tags_1)
		/sizeof(asn_DEF_Set_tags_1[0]), /* 1 */
	asn_DEF_Set_tags_1,	/* Same as above */
	sizeof(asn_DEF_Set_tags_1)
		/sizeof(asn_DEF_Set_tags_1[0]), /* 1 */
	{ 0, 0, SET_constraint },
	asn_MBR_Set_1,
	2,	/* Elements count */
	&asn_SPC_Set_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ExtensibleSet] >>> ***/

#include <UTF8String.h>
#include <ENUMERATED.h>
#include <constr_SET.h>

/*** <<< DEPS [ExtensibleSet] >>> ***/


/*
 * Method of determining the components presence
 */
typedef enum ExtensibleSet_PR {
	ExtensibleSet_PR_string,	/* Member string is present */
	ExtensibleSet_PR_enum,	/* Member enum is present */
} ExtensibleSet_PR;
typedef enum Enum {
	enum_b	= 0,
	enum_a	= 1
} e_enum;

/*** <<< TYPE-DECLS [ExtensibleSet] >>> ***/

typedef struct ExtensibleSet {
	UTF8String_t	*string;	/* OPTIONAL */
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	ENUMERATED_t	*Enum;
	
	/* Presence bitmask: ASN_SET_ISPRESENT(pExtensibleSet, ExtensibleSet_PR_x) */
	unsigned int _presence_map
		[((2+(8*sizeof(unsigned int))-1)/(8*sizeof(unsigned int)))];
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ExtensibleSet_t;

/*** <<< FUNC-DECLS [ExtensibleSet] >>> ***/

/* extern asn_TYPE_descriptor_t asn_DEF_enum_4;	// (Use -fall-defs-global to expose) */
extern asn_TYPE_descriptor_t asn_DEF_ExtensibleSet;
extern asn_SET_specifics_t asn_SPC_ExtensibleSet_specs_1;
extern asn_TYPE_member_t asn_MBR_ExtensibleSet_1[2];

/*** <<< CODE [ExtensibleSet] >>> ***/

/*
 * This type is implemented using ENUMERATED,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [ExtensibleSet] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_enum_value2enum_4[] = {
	{ 0,	1,	"b" },
	{ 1,	1,	"a" }
};
static const unsigned int asn_MAP_enum_enum2value_4[] = {
	1,	/* a(1) */
	0	/* b(0) */
};
static const asn_INTEGER_specifics_t asn_SPC_enum_specs_4 = {
	asn_MAP_enum_value2enum_4,	/* "tag" => N; sorted by tag */
	asn_MAP_enum_enum2value_4,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_enum_tags_4[] = {
	(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_enum_4 = {
	"enum",
	"enum",
	&asn_OP_ENUMERATED,
	asn_DEF_enum_tags_4,
	sizeof(asn_DEF_enum_tags_4)
		/sizeof(asn_DEF_enum_tags_4[0]) - 1, /* 1 */
	asn_DEF_enum_tags_4,	/* Same as above */
	sizeof(asn_DEF_enum_tags_4)
		/sizeof(asn_DEF_enum_tags_4[0]), /* 2 */
	{ 0, 0, ENUMERATED_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_enum_specs_4	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ExtensibleSet_1[] = {
	{ ATF_POINTER, 2, offsetof(struct ExtensibleSet, string),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "string"
		},
	{ ATF_POINTER, 1, offsetof(struct ExtensibleSet, Enum),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_enum_4,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "enum"
		},
};
static const ber_tlv_tag_t asn_DEF_ExtensibleSet_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ExtensibleSet_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* string */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* enum */
};
static const uint8_t asn_MAP_ExtensibleSet_mmap_1[(2 + (8 * sizeof(unsigned int)) - 1) / 8] = {
	(0 << 7) | (0 << 6)
};
asn_SET_specifics_t asn_SPC_ExtensibleSet_specs_1 = {
	sizeof(struct ExtensibleSet),
	offsetof(struct ExtensibleSet, _asn_ctx),
	offsetof(struct ExtensibleSet, _presence_map),
	.tag2el = asn_MAP_ExtensibleSet_tag2el_1,
	.tag2el_count = 2,	/* Count of tags in the map */
	asn_MAP_ExtensibleSet_tag2el_1,	/* Same as above */
	2,	/* Count of tags in the CXER map */
	1,	/* Whether extensible */
	(const unsigned int *)asn_MAP_ExtensibleSet_mmap_1	/* Mandatory elements map */
};
asn_TYPE_descriptor_t asn_DEF_ExtensibleSet = {
	"ExtensibleSet",
	"ExtensibleSet",
	&asn_OP_SET,
	asn_DEF_ExtensibleSet_tags_1,
	sizeof(asn_DEF_ExtensibleSet_tags_1)
		/sizeof(asn_DEF_ExtensibleSet_tags_1[0]), /* 1 */
	asn_DEF_ExtensibleSet_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExtensibleSet_tags_1)
		/sizeof(asn_DEF_ExtensibleSet_tags_1[0]), /* 1 */
	{ 0, 0, SET_constraint },
	asn_MBR_ExtensibleSet_1,
	2,	/* Elements count */
	&asn_SPC_ExtensibleSet_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ExtensibleSequence] >>> ***/

#include <UTF8String.h>
#include <INTEGER.h>
#include <GeneralizedTime.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [ExtensibleSequence] >>> ***/

typedef struct ExtensibleSequence {
	UTF8String_t	*string;	/* OPTIONAL */
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	INTEGER_t	*integer;	/* OPTIONAL */
	GeneralizedTime_t	*gtime;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ExtensibleSequence_t;

/*** <<< FUNC-DECLS [ExtensibleSequence] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ExtensibleSequence;
extern asn_SEQUENCE_specifics_t asn_SPC_ExtensibleSequence_specs_1;
extern asn_TYPE_member_t asn_MBR_ExtensibleSequence_1[3];

/*** <<< STAT-DEFS [ExtensibleSequence] >>> ***/

asn_TYPE_member_t asn_MBR_ExtensibleSequence_1[] = {
	{ ATF_POINTER, 3, offsetof(struct ExtensibleSequence, string),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "string"
		},
	{ ATF_POINTER, 2, offsetof(struct ExtensibleSequence, integer),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "integer"
		},
	{ ATF_POINTER, 1, offsetof(struct ExtensibleSequence, gtime),
		.tag = (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_GeneralizedTime,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "gtime"
		},
};
static const ber_tlv_tag_t asn_DEF_ExtensibleSequence_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ExtensibleSequence_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* string */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* integer */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* gtime */
};
asn_SEQUENCE_specifics_t asn_SPC_ExtensibleSequence_specs_1 = {
	sizeof(struct ExtensibleSequence),
	offsetof(struct ExtensibleSequence, _asn_ctx),
	.tag2el = asn_MAP_ExtensibleSequence_tag2el_1,
	.tag2el_count = 3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ExtensibleSequence = {
	"ExtensibleSequence",
	"ExtensibleSequence",
	&asn_OP_SEQUENCE,
	asn_DEF_ExtensibleSequence_tags_1,
	sizeof(asn_DEF_ExtensibleSequence_tags_1)
		/sizeof(asn_DEF_ExtensibleSequence_tags_1[0]), /* 1 */
	asn_DEF_ExtensibleSequence_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExtensibleSequence_tags_1)
		/sizeof(asn_DEF_ExtensibleSequence_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_ExtensibleSequence_1,
	3,	/* Elements count */
	&asn_SPC_ExtensibleSequence_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [ExtensibleSequence2] >>> ***/

#include <UTF8String.h>
#include <INTEGER.h>
#include <constr_SEQUENCE.h>

/*** <<< TYPE-DECLS [ExtensibleSequence2] >>> ***/

typedef struct ExtensibleSequence2 {
	UTF8String_t	*string;	/* OPTIONAL */
	/*
	 * This type is extensible,
	 * possible extensions are below.
	 */
	INTEGER_t	*integer;	/* OPTIONAL */
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} ExtensibleSequence2_t;

/*** <<< FUNC-DECLS [ExtensibleSequence2] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_ExtensibleSequence2;
extern asn_SEQUENCE_specifics_t asn_SPC_ExtensibleSequence2_specs_1;
extern asn_TYPE_member_t asn_MBR_ExtensibleSequence2_1[2];

/*** <<< STAT-DEFS [ExtensibleSequence2] >>> ***/

asn_TYPE_member_t asn_MBR_ExtensibleSequence2_1[] = {
	{ ATF_POINTER, 2, offsetof(struct ExtensibleSequence2, string),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_UTF8String,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "string"
		},
	{ ATF_POINTER, 1, offsetof(struct ExtensibleSequence2, integer),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "integer"
		},
};
static const ber_tlv_tag_t asn_DEF_ExtensibleSequence2_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ExtensibleSequence2_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* string */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* integer */
};
asn_SEQUENCE_specifics_t asn_SPC_ExtensibleSequence2_specs_1 = {
	sizeof(struct ExtensibleSequence2),
	offsetof(struct ExtensibleSequence2, _asn_ctx),
	.tag2el = asn_MAP_ExtensibleSequence2_tag2el_1,
	.tag2el_count = 2,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ExtensibleSequence2 = {
	"ExtensibleSequence2",
	"ExtensibleSequence2",
	&asn_OP_SEQUENCE,
	asn_DEF_ExtensibleSequence2_tags_1,
	sizeof(asn_DEF_ExtensibleSequence2_tags_1)
		/sizeof(asn_DEF_ExtensibleSequence2_tags_1[0]), /* 1 */
	asn_DEF_ExtensibleSequence2_tags_1,	/* Same as above */
	sizeof(asn_DEF_ExtensibleSequence2_tags_1)
		/sizeof(asn_DEF_ExtensibleSequence2_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_ExtensibleSequence2_1,
	2,	/* Elements count */
	&asn_SPC_ExtensibleSequence2_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SetOfNULL] >>> ***/

#include <NULL.h>
#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< TYPE-DECLS [SetOfNULL] >>> ***/

typedef struct SetOfNULL {
	A_SET_OF(NULL_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SetOfNULL_t;

/*** <<< FUNC-DECLS [SetOfNULL] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SetOfNULL;
extern asn_SET_OF_specifics_t asn_SPC_SetOfNULL_specs_1;
extern asn_TYPE_member_t asn_MBR_SetOfNULL_1[1];

/*** <<< STAT-DEFS [SetOfNULL] >>> ***/

asn_TYPE_member_t asn_MBR_SetOfNULL_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_NULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_SetOfNULL_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_SetOfNULL_specs_1 = {
	sizeof(struct SetOfNULL),
	offsetof(struct SetOfNULL, _asn_ctx),
	1,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_SetOfNULL = {
	"SetOfNULL",
	"SetOfNULL",
	&asn_OP_SET_OF,
	asn_DEF_SetOfNULL_tags_1,
	sizeof(asn_DEF_SetOfNULL_tags_1)
		/sizeof(asn_DEF_SetOfNULL_tags_1[0]), /* 1 */
	asn_DEF_SetOfNULL_tags_1,	/* Same as above */
	sizeof(asn_DEF_SetOfNULL_tags_1)
		/sizeof(asn_DEF_SetOfNULL_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_SetOfNULL_1,
	1,	/* Single element */
	&asn_SPC_SetOfNULL_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SetOfREAL] >>> ***/

#include <REAL.h>
#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< TYPE-DECLS [SetOfREAL] >>> ***/

typedef struct SetOfREAL {
	A_SET_OF(REAL_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SetOfREAL_t;

/*** <<< FUNC-DECLS [SetOfREAL] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SetOfREAL;
extern asn_SET_OF_specifics_t asn_SPC_SetOfREAL_specs_1;
extern asn_TYPE_member_t asn_MBR_SetOfREAL_1[1];

/*** <<< STAT-DEFS [SetOfREAL] >>> ***/

asn_TYPE_member_t asn_MBR_SetOfREAL_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (9 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_REAL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_SetOfREAL_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_SetOfREAL_specs_1 = {
	sizeof(struct SetOfREAL),
	offsetof(struct SetOfREAL, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_SetOfREAL = {
	"SetOfREAL",
	"SetOfREAL",
	&asn_OP_SET_OF,
	asn_DEF_SetOfREAL_tags_1,
	sizeof(asn_DEF_SetOfREAL_tags_1)
		/sizeof(asn_DEF_SetOfREAL_tags_1[0]), /* 1 */
	asn_DEF_SetOfREAL_tags_1,	/* Same as above */
	sizeof(asn_DEF_SetOfREAL_tags_1)
		/sizeof(asn_DEF_SetOfREAL_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_SetOfREAL_1,
	1,	/* Single element */
	&asn_SPC_SetOfREAL_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SetOfEnums] >>> ***/

#include <ENUMERATED.h>
#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< DEPS [SetOfEnums] >>> ***/

typedef enum Member {
	Member_one	= 0,
	Member_oneMore	= 1
} e_Member;

/*** <<< TYPE-DECLS [SetOfEnums] >>> ***/

typedef struct SetOfEnums {
	A_SET_OF(ENUMERATED_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SetOfEnums_t;

/*** <<< FUNC-DECLS [SetOfEnums] >>> ***/

/* extern asn_TYPE_descriptor_t asn_DEF_Member_2;	// (Use -fall-defs-global to expose) */
extern asn_TYPE_descriptor_t asn_DEF_SetOfEnums;
extern asn_SET_OF_specifics_t asn_SPC_SetOfEnums_specs_1;
extern asn_TYPE_member_t asn_MBR_SetOfEnums_1[1];

/*** <<< CODE [SetOfEnums] >>> ***/

/*
 * This type is implemented using ENUMERATED,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [SetOfEnums] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_Member_value2enum_2[] = {
	{ 0,	3,	"one" },
	{ 1,	7,	"oneMore" }
};
static const unsigned int asn_MAP_Member_enum2value_2[] = {
	0,	/* one(0) */
	1	/* oneMore(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_Member_specs_2 = {
	asn_MAP_Member_value2enum_2,	/* "tag" => N; sorted by tag */
	asn_MAP_Member_enum2value_2,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_Member_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_Member_2 = {
	"ENUMERATED",
	"ENUMERATED",
	&asn_OP_ENUMERATED,
	asn_DEF_Member_tags_2,
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	asn_DEF_Member_tags_2,	/* Same as above */
	sizeof(asn_DEF_Member_tags_2)
		/sizeof(asn_DEF_Member_tags_2[0]), /* 1 */
	{ 0, 0, ENUMERATED_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_Member_specs_2	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_SetOfEnums_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_Member_2,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_SetOfEnums_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_SetOfEnums_specs_1 = {
	sizeof(struct SetOfEnums),
	offsetof(struct SetOfEnums, _asn_ctx),
	1,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_SetOfEnums = {
	"SetOfEnums",
	"SetOfEnums",
	&asn_OP_SET_OF,
	asn_DEF_SetOfEnums_tags_1,
	sizeof(asn_DEF_SetOfEnums_tags_1)
		/sizeof(asn_DEF_SetOfEnums_tags_1[0]), /* 1 */
	asn_DEF_SetOfEnums_tags_1,	/* Same as above */
	sizeof(asn_DEF_SetOfEnums_tags_1)
		/sizeof(asn_DEF_SetOfEnums_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_SetOfEnums_1,
	1,	/* Single element */
	&asn_SPC_SetOfEnums_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NamedSetOfNULL] >>> ***/

#include <NULL.h>
#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< TYPE-DECLS [NamedSetOfNULL] >>> ***/

typedef struct NamedSetOfNULL {
	A_SET_OF(NULL_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} NamedSetOfNULL_t;

/*** <<< FUNC-DECLS [NamedSetOfNULL] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NamedSetOfNULL;
extern asn_SET_OF_specifics_t asn_SPC_NamedSetOfNULL_specs_1;
extern asn_TYPE_member_t asn_MBR_NamedSetOfNULL_1[1];

/*** <<< STAT-DEFS [NamedSetOfNULL] >>> ***/

asn_TYPE_member_t asn_MBR_NamedSetOfNULL_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_NULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "y"
		},
};
static const ber_tlv_tag_t asn_DEF_NamedSetOfNULL_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_NamedSetOfNULL_specs_1 = {
	sizeof(struct NamedSetOfNULL),
	offsetof(struct NamedSetOfNULL, _asn_ctx),
	1,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_NamedSetOfNULL = {
	"NamedSetOfNULL",
	"NamedSetOfNULL",
	&asn_OP_SET_OF,
	asn_DEF_NamedSetOfNULL_tags_1,
	sizeof(asn_DEF_NamedSetOfNULL_tags_1)
		/sizeof(asn_DEF_NamedSetOfNULL_tags_1[0]), /* 1 */
	asn_DEF_NamedSetOfNULL_tags_1,	/* Same as above */
	sizeof(asn_DEF_NamedSetOfNULL_tags_1)
		/sizeof(asn_DEF_NamedSetOfNULL_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_NamedSetOfNULL_1,
	1,	/* Single element */
	&asn_SPC_NamedSetOfNULL_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NamedSetOfREAL] >>> ***/

#include <REAL.h>
#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< TYPE-DECLS [NamedSetOfREAL] >>> ***/

typedef struct NamedSetOfREAL {
	A_SET_OF(REAL_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} NamedSetOfREAL_t;

/*** <<< FUNC-DECLS [NamedSetOfREAL] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NamedSetOfREAL;
extern asn_SET_OF_specifics_t asn_SPC_NamedSetOfREAL_specs_1;
extern asn_TYPE_member_t asn_MBR_NamedSetOfREAL_1[1];

/*** <<< STAT-DEFS [NamedSetOfREAL] >>> ***/

asn_TYPE_member_t asn_MBR_NamedSetOfREAL_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (9 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_REAL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "name"
		},
};
static const ber_tlv_tag_t asn_DEF_NamedSetOfREAL_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_NamedSetOfREAL_specs_1 = {
	sizeof(struct NamedSetOfREAL),
	offsetof(struct NamedSetOfREAL, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_NamedSetOfREAL = {
	"NamedSetOfREAL",
	"NamedSetOfREAL",
	&asn_OP_SET_OF,
	asn_DEF_NamedSetOfREAL_tags_1,
	sizeof(asn_DEF_NamedSetOfREAL_tags_1)
		/sizeof(asn_DEF_NamedSetOfREAL_tags_1[0]), /* 1 */
	asn_DEF_NamedSetOfREAL_tags_1,	/* Same as above */
	sizeof(asn_DEF_NamedSetOfREAL_tags_1)
		/sizeof(asn_DEF_NamedSetOfREAL_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_NamedSetOfREAL_1,
	1,	/* Single element */
	&asn_SPC_NamedSetOfREAL_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NamedSetOfEnums] >>> ***/

#include <ENUMERATED.h>
#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< DEPS [NamedSetOfEnums] >>> ***/

typedef enum name {
	name_one	= 0,
	name_oneMore	= 1
} e_name;

/*** <<< TYPE-DECLS [NamedSetOfEnums] >>> ***/

typedef struct NamedSetOfEnums {
	A_SET_OF(ENUMERATED_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} NamedSetOfEnums_t;

/*** <<< FUNC-DECLS [NamedSetOfEnums] >>> ***/

/* extern asn_TYPE_descriptor_t asn_DEF_name_2;	// (Use -fall-defs-global to expose) */
extern asn_TYPE_descriptor_t asn_DEF_NamedSetOfEnums;
extern asn_SET_OF_specifics_t asn_SPC_NamedSetOfEnums_specs_1;
extern asn_TYPE_member_t asn_MBR_NamedSetOfEnums_1[1];

/*** <<< CODE [NamedSetOfEnums] >>> ***/

/*
 * This type is implemented using ENUMERATED,
 * so here we adjust the DEF accordingly.
 */

/*** <<< STAT-DEFS [NamedSetOfEnums] >>> ***/

static const asn_INTEGER_enum_map_t asn_MAP_name_value2enum_2[] = {
	{ 0,	3,	"one" },
	{ 1,	7,	"oneMore" }
};
static const unsigned int asn_MAP_name_enum2value_2[] = {
	0,	/* one(0) */
	1	/* oneMore(1) */
};
static const asn_INTEGER_specifics_t asn_SPC_name_specs_2 = {
	asn_MAP_name_value2enum_2,	/* "tag" => N; sorted by tag */
	asn_MAP_name_enum2value_2,	/* N => "tag"; sorted by N */
	2,	/* Number of elements in the maps */
	0,	/* Enumeration is not extensible */
	1,	/* Strict enumeration */
	0,	/* Native long size */
	0
};
static const ber_tlv_tag_t asn_DEF_name_tags_2[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (10 << 2))
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_name_2 = {
	"ENUMERATED",
	"ENUMERATED",
	&asn_OP_ENUMERATED,
	asn_DEF_name_tags_2,
	sizeof(asn_DEF_name_tags_2)
		/sizeof(asn_DEF_name_tags_2[0]), /* 1 */
	asn_DEF_name_tags_2,	/* Same as above */
	sizeof(asn_DEF_name_tags_2)
		/sizeof(asn_DEF_name_tags_2[0]), /* 1 */
	{ 0, 0, ENUMERATED_constraint },
	0, 0,	/* Defined elsewhere */
	&asn_SPC_name_specs_2	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_NamedSetOfEnums_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_name_2,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "name"
		},
};
static const ber_tlv_tag_t asn_DEF_NamedSetOfEnums_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_NamedSetOfEnums_specs_1 = {
	sizeof(struct NamedSetOfEnums),
	offsetof(struct NamedSetOfEnums, _asn_ctx),
	1,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_NamedSetOfEnums = {
	"NamedSetOfEnums",
	"NamedSetOfEnums",
	&asn_OP_SET_OF,
	asn_DEF_NamedSetOfEnums_tags_1,
	sizeof(asn_DEF_NamedSetOfEnums_tags_1)
		/sizeof(asn_DEF_NamedSetOfEnums_tags_1[0]), /* 1 */
	asn_DEF_NamedSetOfEnums_tags_1,	/* Same as above */
	sizeof(asn_DEF_NamedSetOfEnums_tags_1)
		/sizeof(asn_DEF_NamedSetOfEnums_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_NamedSetOfEnums_1,
	1,	/* Single element */
	&asn_SPC_NamedSetOfEnums_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SequenceOf] >>> ***/

#include <INTEGER.h>
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< TYPE-DECLS [SequenceOf] >>> ***/

typedef struct SequenceOf {
	A_SEQUENCE_OF(INTEGER_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SequenceOf_t;

/*** <<< FUNC-DECLS [SequenceOf] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SequenceOf;
extern asn_SET_OF_specifics_t asn_SPC_SequenceOf_specs_1;
extern asn_TYPE_member_t asn_MBR_SequenceOf_1[1];

/*** <<< STAT-DEFS [SequenceOf] >>> ***/

asn_TYPE_member_t asn_MBR_SequenceOf_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_INTEGER,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "id"
		},
};
static const ber_tlv_tag_t asn_DEF_SequenceOf_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
asn_SET_OF_specifics_t asn_SPC_SequenceOf_specs_1 = {
	sizeof(struct SequenceOf),
	offsetof(struct SequenceOf, _asn_ctx),
	0,	/* XER encoding is XMLDelimitedItemList */
};
asn_TYPE_descriptor_t asn_DEF_SequenceOf = {
	"SequenceOf",
	"SequenceOf",
	&asn_OP_SEQUENCE_OF,
	asn_DEF_SequenceOf_tags_1,
	sizeof(asn_DEF_SequenceOf_tags_1)
		/sizeof(asn_DEF_SequenceOf_tags_1[0]), /* 1 */
	asn_DEF_SequenceOf_tags_1,	/* Same as above */
	sizeof(asn_DEF_SequenceOf_tags_1)
		/sizeof(asn_DEF_SequenceOf_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_OF_constraint },
	asn_MBR_SequenceOf_1,
	1,	/* Single element */
	&asn_SPC_SequenceOf_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SeqOfZuka] >>> ***/

#include <NULL.h>
#include <asn_SEQUENCE_OF.h>
#include <constr_SEQUENCE_OF.h>

/*** <<< TYPE-DECLS [SeqOfZuka] >>> ***/

typedef struct SeqOfZuka {
	A_SEQUENCE_OF(NULL_t) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SeqOfZuka_t;

/*** <<< FUNC-DECLS [SeqOfZuka] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SeqOfZuka;
extern asn_SET_OF_specifics_t asn_SPC_SeqOfZuka_specs_1;
extern asn_TYPE_member_t asn_MBR_SeqOfZuka_1[1];

/*** <<< STAT-DEFS [SeqOfZuka] >>> ***/

asn_TYPE_member_t asn_MBR_SeqOfZuka_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = (ASN_TAG_CLASS_UNIVERSAL | (5 << 2)),
		.tag_mode = 0,
		.type = &asn_DEF_NULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "zuka"
		},
};
static const ber_tlv_tag_t asn_DEF_SeqOfZuka_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
asn_SET_OF_specifics_t asn_SPC_SeqOfZuka_specs_1 = {
	sizeof(struct SeqOfZuka),
	offsetof(struct SeqOfZuka, _asn_ctx),
	1,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_SeqOfZuka = {
	"SeqOfZuka",
	"SeqOfZuka",
	&asn_OP_SEQUENCE_OF,
	asn_DEF_SeqOfZuka_tags_1,
	sizeof(asn_DEF_SeqOfZuka_tags_1)
		/sizeof(asn_DEF_SeqOfZuka_tags_1[0]), /* 1 */
	asn_DEF_SeqOfZuka_tags_1,	/* Same as above */
	sizeof(asn_DEF_SeqOfZuka_tags_1)
		/sizeof(asn_DEF_SeqOfZuka_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_OF_constraint },
	asn_MBR_SeqOfZuka_1,
	1,	/* Single element */
	&asn_SPC_SeqOfZuka_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SetOfChoice] >>> ***/

#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< FWD-DECLS [SetOfChoice] >>> ***/

struct SimpleChoice;

/*** <<< TYPE-DECLS [SetOfChoice] >>> ***/

typedef struct SetOfChoice {
	A_SET_OF(struct SimpleChoice) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SetOfChoice_t;

/*** <<< FUNC-DECLS [SetOfChoice] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SetOfChoice;
extern asn_SET_OF_specifics_t asn_SPC_SetOfChoice_specs_1;
extern asn_TYPE_member_t asn_MBR_SetOfChoice_1[1];

/*** <<< POST-INCLUDE [SetOfChoice] >>> ***/

#include "SimpleChoice.h"

/*** <<< STAT-DEFS [SetOfChoice] >>> ***/

asn_TYPE_member_t asn_MBR_SetOfChoice_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = -1 /* Ambiguous tag (CHOICE?) */,
		.tag_mode = 0,
		.type = &asn_DEF_SimpleChoice,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = ""
		},
};
static const ber_tlv_tag_t asn_DEF_SetOfChoice_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_SetOfChoice_specs_1 = {
	sizeof(struct SetOfChoice),
	offsetof(struct SetOfChoice, _asn_ctx),
	2,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_SetOfChoice = {
	"SetOfChoice",
	"SetOfChoice",
	&asn_OP_SET_OF,
	asn_DEF_SetOfChoice_tags_1,
	sizeof(asn_DEF_SetOfChoice_tags_1)
		/sizeof(asn_DEF_SetOfChoice_tags_1[0]), /* 1 */
	asn_DEF_SetOfChoice_tags_1,	/* Same as above */
	sizeof(asn_DEF_SetOfChoice_tags_1)
		/sizeof(asn_DEF_SetOfChoice_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_SetOfChoice_1,
	1,	/* Single element */
	&asn_SPC_SetOfChoice_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [NamedSetOfChoice] >>> ***/

#include <asn_SET_OF.h>
#include <constr_SET_OF.h>

/*** <<< FWD-DECLS [NamedSetOfChoice] >>> ***/

struct SimpleChoice;

/*** <<< TYPE-DECLS [NamedSetOfChoice] >>> ***/

typedef struct NamedSetOfChoice {
	A_SET_OF(struct SimpleChoice) list;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} NamedSetOfChoice_t;

/*** <<< FUNC-DECLS [NamedSetOfChoice] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_NamedSetOfChoice;
extern asn_SET_OF_specifics_t asn_SPC_NamedSetOfChoice_specs_1;
extern asn_TYPE_member_t asn_MBR_NamedSetOfChoice_1[1];

/*** <<< POST-INCLUDE [NamedSetOfChoice] >>> ***/

#include "SimpleChoice.h"

/*** <<< STAT-DEFS [NamedSetOfChoice] >>> ***/

asn_TYPE_member_t asn_MBR_NamedSetOfChoice_1[] = {
	{ ATF_POINTER, 0, 0,
		.tag = -1 /* Ambiguous tag (CHOICE?) */,
		.tag_mode = 0,
		.type = &asn_DEF_SimpleChoice,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "whatever"
		},
};
static const ber_tlv_tag_t asn_DEF_NamedSetOfChoice_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (17 << 2))
};
asn_SET_OF_specifics_t asn_SPC_NamedSetOfChoice_specs_1 = {
	sizeof(struct NamedSetOfChoice),
	offsetof(struct NamedSetOfChoice, _asn_ctx),
	2,	/* XER encoding is XMLValueList */
};
asn_TYPE_descriptor_t asn_DEF_NamedSetOfChoice = {
	"NamedSetOfChoice",
	"NamedSetOfChoice",
	&asn_OP_SET_OF,
	asn_DEF_NamedSetOfChoice_tags_1,
	sizeof(asn_DEF_NamedSetOfChoice_tags_1)
		/sizeof(asn_DEF_NamedSetOfChoice_tags_1[0]), /* 1 */
	asn_DEF_NamedSetOfChoice_tags_1,	/* Same as above */
	sizeof(asn_DEF_NamedSetOfChoice_tags_1)
		/sizeof(asn_DEF_NamedSetOfChoice_tags_1[0]), /* 1 */
	{ 0, 0, SET_OF_constraint },
	asn_MBR_NamedSetOfChoice_1,
	1,	/* Single element */
	&asn_SPC_NamedSetOfChoice_specs_1	/* Additional specs */
};


/*** <<< INCLUDES [SimpleChoice] >>> ***/

#include <NULL.h>
#include <INTEGER.h>
#include <constr_CHOICE.h>

/*** <<< DEPS [SimpleChoice] >>> ***/

typedef enum SimpleChoice_PR {
	SimpleChoice_PR_NOTHING,	/* No components present */
	SimpleChoice_PR_a,
	SimpleChoice_PR_b
} SimpleChoice_PR;

/*** <<< TYPE-DECLS [SimpleChoice] >>> ***/

typedef struct SimpleChoice {
	SimpleChoice_PR present;
	union SimpleChoice_u {
		NULL_t	 a;
		INTEGER_t	 b;
	} choice;
	
	/* Context for parsing across buffer boundaries */
	asn_struct_ctx_t _asn_ctx;
} SimpleChoice_t;

/*** <<< FUNC-DECLS [SimpleChoice] >>> ***/

extern asn_TYPE_descriptor_t asn_DEF_SimpleChoice;
extern asn_CHOICE_specifics_t asn_SPC_SimpleChoice_specs_1;
extern asn_TYPE_member_t asn_MBR_SimpleChoice_1[2];

/*** <<< STAT-DEFS [SimpleChoice] >>> ***/

asn_TYPE_member_t asn_MBR_SimpleChoice_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct SimpleChoice, choice.a),
		.tag = (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_NULL,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "a"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct SimpleChoice, choice.b),
		.tag = (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		.tag_mode = -1,	/* IMPLICIT tag at current level */
		.type = &asn_DEF_INTEGER,
		.type_selector = 0,
		{ .oer_constraints = 0, .per_constraints = 0, .general_constraints = 0 },
		0, 0, /* No default value */
		.name = "b"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_SimpleChoice_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* a */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 } /* b */
};
asn_CHOICE_specifics_t asn_SPC_SimpleChoice_specs_1 = {
	sizeof(struct SimpleChoice),
	offsetof(struct SimpleChoice, _asn_ctx),
	offsetof(struct SimpleChoice, present),
	sizeof(((struct SimpleChoice *)0)->present),
	.tag2el = asn_MAP_SimpleChoice_tag2el_1,
	.tag2el_count = 2,	/* Count of tags in the map */
	0, 0,
	.first_extension = -1	/* Extensions start */
};
asn_TYPE_descriptor_t asn_DEF_SimpleChoice = {
	"SimpleChoice",
	"SimpleChoice",
	&asn_OP_CHOICE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, CHOICE_constraint },
	asn_MBR_SimpleChoice_1,
	2,	/* Elements count */
	&asn_SPC_SimpleChoice_specs_1	/* Additional specs */
};

